<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>xuehaolin</title>
    <url>/2020/09/28/xuehaolin/</url>
    <content><![CDATA[<p>这是我的第一个用GitHub+hexo搭建的博客网站，我希望用这个博客可以记录我的日常学习生活，我沿途遇到的风景以及我看过的书，或者是我对某一件事的看法，我希望多年以后这里可以是我的一路走来的驻足地。</p>
]]></content>
  </entry>
  <entry>
    <title>AOP原来这样做</title>
    <url>/2020/09/29/AOP%E5%8E%9F%E6%9D%A5%E8%BF%99%E6%A0%B7%E5%81%9A/</url>
    <content><![CDATA[<p>1-简介<br>审计日记就是记录用户的操作记录<br>基于AOP动态代理 实现自定义审计日志注解, 并支持Spel表达式解析<br>2-实现<br>2-1 日志存储实体类</p>
<a id="more"></a>
<p>复制代码<br>@Data<br>@Builder<br>@ToString<br>public class AuditingLog {</p>
<pre><code>private String userId;  // 用户id

private String userNickname; //用户昵称

private String operationInfo; //操作信息

private String interfaceName; // 调用的接口方法名

private String applicationName; // 调用的服务名

private LocalDateTime createTime; //操作时间</code></pre>
<p>}<br>复制代码</p>
<p>2-2 自定义审计日志注解<br>@Documented<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target({ElementType.TYPE, ElementType.METHOD})<br>public @interface AuditLog {<br>    String logInfo(); //日志信息<br>}<br>2-3 日志注解的AOP的切面<br>复制代码<br>@Aspect<br>@Component<br>public class AuditLogAOP {</p>
<pre><code>   @Value(&quot;$&#123;spring.application.name&#125;&quot;)
private String applicationName; //从配置文件获得服务名

// spel表达式解析器
private SpelExpressionParser spelExpressionParser = new SpelExpressionParser();

// 参数名发现器
private DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();

@Before(value = &quot;@annotation(enableAuditLog) || @within(enableAuditLog)&quot;)
public void getAutiLogInfo(JoinPoint joinPoint, AuditLog enableAuditLog)&#123;

    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
    if (enableAuditLog == null) &#123;
        enableAuditLog = signature.getMethod().getAnnotation(AuditLog.class);
    &#125;

    // 构建日志存储对象
    AuditingLog auditlog = AuditingLog.builder().applicationName(applicationName).createTime(LocalDateTime.now()).build();

    auditlog.setUserId(xxx);  // 从上下文获取当前操作的用户信息
    auditlog.setUserNickname(xx);

// 设置操作的接口方法名        
auditlog.setInterfaceName(signature.getDeclaringTypeName()+&quot;.&quot;+signature.getName());

    // 获得日志注解上自定义的日志信息
    String logInfo = enableAuditLog.logInfo();

    // Spel表达式解析日志信息
    // 获得方法参数名数组
    String[] parameterNames = parameterNameDiscoverer.getParameterNames(signature.getMethod());
    if (parameterNames != null &amp;&amp; parameterNames.length &gt; 0)&#123;
        EvaluationContext context = new StandardEvaluationContext();

        //获取方法参数值
        Object[] args = joinPoint.getArgs();
        for (int i = 0; i &lt; args.length; i++) &#123;
            context.setVariable(parameterNames[i],args[i]); // 替换spel里的变量值为实际值， 比如 #user --&gt;  user对象
        &#125;

        // 解析出实际的日志信息
        String opeationInfo = spelExpressionParser.parseExpression(logInfo).getValue(context).toString();
        auditlog.setOperationInfo(opeationInfo);
    &#125;

    // 打印日志信息
    log.info(auditlog.toString());

    //TODO 这时可以将日志信息auditlog进行异步存储,比如写入到文件通过logstash增量的同步到Elasticsearch或者DB

&#125;</code></pre>
<p>}<br>复制代码<br>2-4 开启审计日志功能<br>在分布式项目中一般会将日志抽离出来公共调用, 所以为了方便的注入审计日志功能,可以编写对应 Enable注解<br>@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Import({AuditLogAOP.class}) // 注入AOP切面到容器<br>public @interface EnableAuditLog {</p>
<p>}<br>3 使用<br>3-1 开启审计日志功能<br>在要使用审计日志功能的服务的入口类开启审计日志功能<br>比如</p>
<p>复制代码<br>@SpringBootApplication<br>@EnableDiscoveryClient<br>@EnableAuditLog //开启审计日志<br>public class UmsAdminApplication {<br>    public static void main(String[] args) {<br>        SpringApplication.run(UmsAdminApplication.class,args);<br>    }<br>}<br>复制代码<br>3-2 在接口上使用<br>比如:</p>
<pre><code>@AuditLog(logInfo = &quot;&#39;新增管理员:&#39;+ #user.username&quot;)
@PostMapping
public String addUser(@RequestBody User user)&#123;

    return null;
&#125;</code></pre>
<p>转载：<a href="https://blog.csdn.net/weixin_41347419/article/details/107573038">https://blog.csdn.net/weixin_41347419/article/details/107573038</a></p>
]]></content>
  </entry>
  <entry>
    <title>四六级同义词替换（加分项）</title>
    <url>/2020/09/29/%E5%9B%9B%E5%85%AD%E7%BA%A7%E5%90%8C%E4%B9%89%E8%AF%8D%E6%9B%BF%E6%8D%A2%EF%BC%88%E5%8A%A0%E5%88%86%E9%A1%B9%EF%BC%89/</url>
    <content><![CDATA[<p>1、healthy可以指代人身体健康的意思，wholesome的话更偏向于物品有益于健康这种，如果是修饰人的话更接近于健全的意思，有一点区别！<br>2、惊人的同义词里我再加一个striking吧（简单好记就是不那么高级）<br>3、improve的同义词（说近义词更好一点）如果表示有益于的话，可以用avail</p>
<a id="more"></a>
<p>4、solve更接近于解决的意思，而同义词里的cope with和deal with更接近于处理（不一定解决），这个也有一点点区别！<br>5、鼓舞的通过一次还可以是inspire<br>6、think的话可以替换成maintain，短语的话也可以是be convinced that<br>7、influence名词可换成effect，动词可以是affect<br>8、capacity这个词注意，他只表示能力这个词本身，比如你可以说he can go now或者he is able to go now，但是你不能说he have capacityto go now，更不能用capability，意思不一样！<br>9、职业的同义词我还能想到vocation，但是这个跟career一样，和另外三个是有一点区别der<br>10、children的话，也可以说inferior，表示晚辈，同时也有次品的意思，按需取用8<br>11、最后面的a vast number of只能修饰可数词，a vast amount of只可修饰不可数词<br>（诶？！怎么比上次打的少两条！实在想不起来廖随便补充一点8）<br>12、前面提到inferior是晚辈，所以还有peer表示平辈，以及seniority表示长辈<br>13、只修饰可数的还有quite a few，只修饰不可数的还有a great deal of，quite a little，既可修饰可数也可修饰不可数的有plenty of，a large quantity of以及a good supply of<br>13、困难障碍的话，不要再用difficulty或者trouble了！可以试试hardship，obstacle，hindrance等等<br>14、enough可以替换为sufficient，adequate，ample等等（仅表示足够的这个意思时！）<br>15、缺点：disadvantage（这个应该是最普通的？），fault（这个阔能是第二普通的？），drawback，shortcoming，defect<br>16、限制：limit→restrict，restrain，confine<br>17、各种说（say，speak，talk）：轻声说：whisper，murmur，阐明：explain，illustrate，account for ，宣布：declare，announce，claim，大喊：shout，cry out，yell，exclaim，演讲deliver a lecture<br>18、真诚：sincere，cordial，hearty，genuine，faithful<br>19、重要：important→significant，vital，crucial，considerable，essential（这个是基本的，必要的），indispensable（不可或缺的）<br>20、著名的：famous→noted，notable，famed，distinguished，reputable（声誉好的，受尊敬的）<br>21、支持：support→sustain，second，back<br>22、相似的：similar→alike，semblable，analogical（同理相似的动词resemble，相似或者说类比的名词analogy）<br>23、推测：guess→gather，speculate，conjecture<br>这些都是比较常见的词8，虽然替换词能加分，但 一 定 一 定 一 定 要事先挑好一两个你要用来替换的词，只背这一两个，然后弄清楚他的意思，绝对不能用错！不然扣分很严重！（虽然没有考过六级但以前其他考试都是这样的！）<br>祝我们四六级都考好！<br>24、大概这个词，probably、possibly、maybe→presumably、approximately<br>25、商品：things→（日用daily→routine）merchandise、commodity、ware<br>26、恭维、称赞：praise→compliment<br>27、致意：treat→hail、greet（salute表示行军礼）<br>28、深刻的：deep→profound<br>29、（研究、调查等）显示、反应、表明：show→reveal、reflect、mirror、dedicate（指出）<br>30、之前的缺点还有deficiency、flaw、scarcity<br>31、誓言：swear→vow、pledge、oath<br>32、请求：request、ask、beg→plea（n.）petition（n.&amp;vt.）<br>33、反对：disagree→oppose、object to、protest<br>34、极大的：big、large、vast→supreme、tremendous、overwhelming、massive、drastical、substantial、enormous（这里一定要弄清意思再用！）<br>35、各种优秀的杰出的精彩的等等：brilliant、magnificent、remarkable、superb、splendid、distinguished、wonderful、breathtaking、stunning、fantastic、unexceptionable、marvelous、extraordinary、outstanding、eminent<br>36、5G：the 5th generation wireless systems；垃圾分类：garbage classification；传统文化：traditional culture；文化自信：culture confidence<br>okk啦！我比较喜欢36这个数字，就到此为止8~<br>还是那句话，一定要先查清意思再去使用哦~<br>大家一起冲冲冲！四六级加油！</p>
]]></content>
  </entry>
  <entry>
    <title>Eclipse中创建项目</title>
    <url>/2020/09/30/Eclipse%E4%B8%AD%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>第一步：首先导入前面命令行建立的两个maven项目Hello和HelloFriend。<br>方法：选择file–&gt;import–&gt;Existing MAVEN PROJECTS选项选择对应项目路径导入即可<br>第二步：按顺序先后执行Hello和HelloFriend项目的的构建</p>
<a id="more"></a>
<p>方法：右击各自项目pom.xml文件，选择run as中的maven install命令将构件安装至仓库中<br>第三步：通过eclipse新建第三个maven项目。选择file–&gt;new–&gt;other–&gt;MAVEN PROJECT选项<br>第四步：在src/main/java中新建文件cn.itcast.maven.MakeFriends.java<br>package cn.itcast.maven;<br>public class MakeFriends {<br>public String makeFriends(String name){</p>
<pre><code>HelloFriend friend = new HelloFriend();
friend.sayHelloToFriend(&quot;litingwei&quot;);   
String str = &quot;Hey,&quot;+friend.getMyName()+&quot; make a friend please.&quot;;
System.out.println(str);
return str;</code></pre>
<p>}<br>}<br>第五步：在src/test/java中新建文件cn.itcast.maven.MakeFriendsTest.java<br>package cn.itcast.maven;<br>import static junit.framework.Assert.assertEquals;<br>import static org.junit.Assert.*;<br>import org.junit.Test;<br>public class MakeFriendsTest {<br>@Test<br>public void testMakeFriends(){<br>    MakeFriends makeFriend = new MakeFriends();<br>    String str = makeFriend.makeFriends(“litingwei”);<br>    assertEquals(“Hey,John make a friend please.”,str);<br>}<br>}<br>第六步：点击根目录pom.xml添加依赖<br> <dependencies><br>    <dependency><br>        <groupId>junit</groupId><br>        <artifactId>junit</artifactId><br>        <version>4.9</version><br>        <scope>test</scope><br>    </dependency><br>    <dependency><br>        <groupId>cn.itcast.maven</groupId><br>        <artifactId>HelloFriend</artifactId><br>        <version>0.0.1-SNAPSHOT</version><br>        <type>jar</type><br>        <scope>compile</scope><br>  </dependency><br> </dependencies><br>第七步：右击pom.xml选择run as 中的命令执行即可</p>
]]></content>
  </entry>
  <entry>
    <title>Eclipse中创建web项目</title>
    <url>/2020/09/30/Eclipse%E4%B8%AD%E5%88%9B%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>第一步：<br>创建maven web工程<br>第二步:<br>继承parent</p>
<a id="more"></a>
<p>修改pom.xml文件如下<br>4.0.0<br>cn.itcast.maven<br>web<br>war<br>web Maven Webapp<br><a href="http://maven.apache.org/">http://maven.apache.org</a><br>第三步：<br>建立测试jsp<br>&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>pageEncoding=”UTF-8”%&gt;<br>&lt;%@ page import=”cn.itcast.maven.MakeFriends.*”%&gt;<br>&lt;%<br>MakeFriends makeFriends=new MakeFriends();<br>out.println(makeFriends.makeFriends(“wanglipeng”));<br>%&gt;<br>第四步：<br>自动部署到tomcat下面<br>web<br>org.codehaus.cargo<br>cargo-maven2-plugin<br>1.2.3<br>tomcat5x<br>D:/Program Files/Apache Software Foundation/Tomcat 5.0<br>existing<br>D:/Program Files/Apache Software Foundation/Tomcat 5.0<br>cargo-run<br>install<br>run</p>
]]></content>
  </entry>
  <entry>
    <title>spark电子书</title>
    <url>/2020/09/30/spark%E7%94%B5%E5%AD%90%E4%B9%A6/</url>
    <content><![CDATA[<p><a href="http://dblab.xmu.edu.cn/blog/spark/%C2%B7">http://dblab.xmu.edu.cn/blog/spark/·</a><br>Scala Range<br>在执行for循环时，我们经常会用到数值序列，比如，i的值从1循环到5，这时就可以采用Ra</p>
<a id="more"></a>
<p>在创建Range时，需要给出区间的起点和终点以及步长（默认步长为1）。下面通过几个实例来介绍：<br>（1）创建一个从1到5的数值序列，包含区间终点5，步长为1<br>scala&gt; 1 to 5<br>res0: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)<br>scala<br>之前我们已经介绍过，在Scala中允许对“字面量”直接执行方法，所以，上面的代码，也可以用下面的代码来实现：<br>scala&gt; 1.to(5)<br>res0: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5)<br>scala<br>（2）创建一个从1到5的数值序列，不包含区间终点5，步长为1<br>scala&gt; 1 until 5<br>res1: scala.collection.immutable.Range = Range(1, 2, 3, 4)<br>scala<br>（3）创建一个从1到10的数值序列，包含区间终点10，步长为2<br>scala&gt; 1 to 10 by 2<br>res2: scala.collection.immutable.Range = Range(1, 3, 5, 7, 9)<br>scala<br>（4）创建一个Float类型的数值序列，从0.5f到5.9f，步长为0.8f<br>scala&gt; 0.5f to 5.9f by 0.8f<br>res3: scala.collection.immutable.NumericRange[Float] = NumericRange(0.5, 1.3, 2.1, 2.8999999, 3.6999998, 4.5, 5.3)<br>Scala解释器= scalaREPL<br>3种运行的方式（针对Sn求级数和）<br>1.一句一句实现在repl中  逻辑上的一行<br>2.脚本文件 test1.scala存放不带有对象和main的所有代码 ，load运行<br>3.脚本文件 test2scala，存放带有对象和main的所有代码，编译scalac打包java\scala运行</p>
]]></content>
  </entry>
  <entry>
    <title>第一个maven项目</title>
    <url>/2020/09/30/%E7%AC%AC%E4%B8%80%E4%B8%AAmaven%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>第一步. 首先建立Hello项目同时建立Maven约定的目录结构<br>Hello</p>
<a id="more"></a>
<p>–src<br>—–main<br>———-java<br>———-resources<br>—–test<br>———java<br>———resources<br>–pom.xml<br>第二步：在项目Hello根目录建立pom.xml<br><dependencies><br>    <dependency><br>        <groupId>junit</groupId><br>        <artifactId>junit</artifactId><br>        <version>4.9</version><br>        <scope>test</scope><br>    </dependency>       </p>
</dependencies>
第三步：在src/main/java/cn/itcast/maven目录下新建文件Hello.java
package cn.itcast.maven;
public class Hello {
public String sayHello(String name){
    return "Hello "+name+"!";
}
}
第四步：在/src/test/java/cn/itcast/maven目录下新建测试文件HelloTest.java
package cn.itcast.maven;
import org.junit.Test;
import static junit.framework.Assert.*;
public class HelloTest {
@Test
public void testHello(){

<pre><code>Hello hello = new Hello();
String results = hello.sayHello(&quot;litingwei&quot;);
assertEquals(&quot;Hello litingwei!&quot;,results);       </code></pre>
<p>}<br>}<br>第五步：<br>a)打开cmd命令行，进入Hello项目根目录执行 mvn compile命令，查看根目录变化<br>b)cmd 中继续录入mvn clean命令，然后再次查看根目录变化<br>c)cmd 中录入 mvn clean compile命令, 查看根目录变化<br>d)cmd 中录入 mvn clean test命令，查看根目录变化<br>e)cmd 中录入 mvn clean package命令,查看根目录变化</p>
]]></content>
  </entry>
  <entry>
    <title>如何下载、安装、配置和调试 JDK</title>
    <url>/2020/09/30/JDK/</url>
    <content><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>本章介绍了如何下载、安装、配置和调试 JDK。</p>
<h2 id="下载、安装-JDK"><a href="#下载、安装-JDK" class="headerlink" title="下载、安装 JDK"></a>下载、安装 JDK</h2><p>JDK(Java Development Kit)是用于 Java 开发的工具箱。</p>
<a id="more"></a>

<p>在<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>下载</p>
<p>JDK 支持如下操作系统的安装：</p>
<table>
<thead>
<tr>
<th>操作系统类型</th>
<th>文件大小</th>
<th>文件</th>
</tr>
</thead>
<tbody><tr>
<td>Linux x86</td>
<td>154.67 MB</td>
<td>jdk-8u66-linux-i586.rpm</td>
</tr>
<tr>
<td>Linux x86</td>
<td>174.83 MB</td>
<td>jdk-8u66-linux-i586.tar.gz</td>
</tr>
<tr>
<td>Linux x64</td>
<td>152.69 MB</td>
<td>jdk-8u66-linux-x64.rpm</td>
</tr>
<tr>
<td>Linux x64</td>
<td>172.89 MB</td>
<td>jdk-8u66-linux-x64.tar.gz</td>
</tr>
<tr>
<td>Mac OS X x64</td>
<td>227.12 MB</td>
<td>jdk-8u66-macosx-x64.dmg</td>
</tr>
<tr>
<td>Solaris SPARC 64-bit (SVR4 package)</td>
<td>139.65 MB</td>
<td>jdk-8u66-solaris-sparcv9.tar.Z</td>
</tr>
<tr>
<td>Solaris SPARC 64-bit</td>
<td>99.05 MB</td>
<td>jdk-8u66-solaris-sparcv9.tar.gz</td>
</tr>
<tr>
<td>Solaris x64 (SVR4 package)</td>
<td>140 MB</td>
<td>jdk-8u66-solaris-x64.tar.Z</td>
</tr>
<tr>
<td>Solaris x64</td>
<td>96.2 MB</td>
<td>jdk-8u66-solaris-x64.tar.gz</td>
</tr>
<tr>
<td>Windows x86</td>
<td>181.33 MB</td>
<td>jdk-8u66-windows-i586.exe</td>
</tr>
<tr>
<td>Windows x64</td>
<td>186.65 MB</td>
<td>jdk-8u66-windows-x64.exe</td>
</tr>
</tbody></table>
<p>安装路径默认安装在 <code>C:\Program Files\Java\jdk1.8.0_66</code> 或者 <code>usr/local/java/jdk1.8.0_66</code></p>
<p><strong>注：</strong>本书中所使用JDK版本为：Java Platform (JDK) 8u66。<br>本书所使用的操作系统为：Win7 Sp1 x64。本书的示例是在 Eclipse  Mars.1 Release (4.5.1) 工具下编写。</p>
<h3 id="基于-RPM-的-Linux"><a href="#基于-RPM-的-Linux" class="headerlink" title="基于 RPM 的 Linux"></a>基于 RPM 的 Linux</h3><p>（1）下载安装文件</p>
<p>文件名类似于<code>jdk-8uversion-linux-x64.rpm</code>。</p>
<p>（2）切换到 root 用户身份</p>
<p>（3）检查当前的安装情况。卸载老版本的 JDK</p>
<p>检查当前的安装情况，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -qa | grep  jdk</span></span><br><span class="line">jdk1.8.0_102-1.8.0_102-fcs.x86_64</span><br></pre></td></tr></table></figure>

<p>若有老版本 JDK，则需先卸载老版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -e package_name</span></span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -e jdk1.8.0_102-1.8.0_102-fcs.x86_64</span></span><br></pre></td></tr></table></figure>

<p>（4）安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -ivh jdk-8uversion-linux-x64.rpm</span></span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -ivh jdk-8u102-linux-x64.rpm</span></span><br><span class="line">Preparing...                ########################################### [100%]</span><br><span class="line">   1:jdk1.8.0_102           ########################################### [100%]</span><br><span class="line">Unpacking JAR files...</span><br><span class="line">	tools.jar...</span><br><span class="line">	plugin.jar...</span><br><span class="line">	javaws.jar...</span><br><span class="line">	deploy.jar...</span><br><span class="line">	rt.jar...</span><br><span class="line">	jsse.jar...</span><br><span class="line">	charsets.jar...</span><br><span class="line">	localedata.jar...</span><br></pre></td></tr></table></figure>

<p>（5）升级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm -Uvh jdk-8uversion-linux-x64.rpm</span></span><br></pre></td></tr></table></figure>

<p>安装完成后，可以删除<code>.rpm</code>文件，以节省空间。 安装完后，无需重启主机，即可使用 JDK。</p>
<h2 id="设置执行路径"><a href="#设置执行路径" class="headerlink" title="设置执行路径"></a>设置执行路径</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>增加一个 <code>JAVA_HOME</code> 环境变量，值是 JDK 的安装目录。如 <code>C:\Program Files\Java\jdk1.8.0_66</code> ，注意后边不带分号</p>
<p>在 <code>PATH</code> 的环境变量里面增加 <code>%JAVA_HOME%\bin;</code> </p>
<p>在 <code>CLASSPATH</code>增加<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code>（前面有点号和分号，后边结尾也有分号。<br>或者可以写成<code>.;%JAVA_HOME%\lib</code>如图所示，一样的效果。</p>
<h3 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h3><p>包括 Linux、Mac OS X 和 Solaris 环境下，在<code>~/.profile</code>、<code>~/.bashrc</code>或 <code>~/.bash_profile</code> 文件末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_66</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>JAVA_HOME 是 JDK 安装目录</li>
<li>Linux 下用冒号“:”来分隔路径</li>
<li>$PATH 、$CLASSPATH、 $JAVA_HOME 是用来引用原来的环境变量的值</li>
<li>export 是把这三个变量导出为全局变量</li>
</ul>
<p>比如，在 CentOS 下，需编辑<code>/etc/profile</code>文件。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试安装是否正确，可以在 shell 窗口，键入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -version</span></span><br></pre></td></tr></table></figure>

<p>若能看到如下信息，则说明 JDK 安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java version &quot;1.8.0_66&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_66-b17)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.66-b17, mixed mode)</span><br></pre></td></tr></table></figure>

<p>最好再执行下<code>javac</code>，以测试环境变量是否设置正确：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac</span></span><br><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -g                         生成所有调试信息</span><br><span class="line">  -g:none                    不生成任何调试信息</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     只生成某些调试信息</span><br><span class="line">  -nowarn                    不生成任何警告</span><br><span class="line">  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">  -version                   版本信息</span><br><span class="line">  -help                      输出标准选项的提要</span><br><span class="line">  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">  -X                         输出非标准选项的提要</span><br><span class="line">  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">  -Werror                    出现警告时终止编译</span><br><span class="line">  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br></pre></td></tr></table></figure>

<p>有读者反映有时候<code>java -version</code>能够执行成功，但<code>javac</code>命令不成功的情况，一般是环境变量配置问题，请参阅上面“设置执行路径”章节内容，再仔细检测环境变量的配置。</p>
<p>更多安装细节，可以参考 <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html">http://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html</a>，以及<a href="http://docs.oracle.com/javase/tutorial/essential/environment/paths.html">http://docs.oracle.com/javase/tutorial/essential/environment/paths.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>concurrencyImmutableObject</title>
    <url>/2020/09/30/Object/</url>
    <content><![CDATA[<h2 id="不可变对象（Immutable-Objects）"><a href="#不可变对象（Immutable-Objects）" class="headerlink" title="不可变对象（Immutable Objects）"></a>不可变对象（Immutable Objects）</h2><p>如果一个对象它被构造后其，状态不能改变，则这个对象被认为是不可变的（immutable ）。不可变对象的好处是可以创建简单的、可靠的代码。</p>
<a id="more"></a>
<p>不可变对象在并发应用种特别有用。因为他们不能改变状态，它们不能被线程干扰所中断或者被其他线程观察到内部不一致的状态。</p>
<p>程序员往往不愿使用不可变对象，因为他们担心创建一个新的对象要比更新对象的成本要高。实际上这种开销常常被过分高估，而且使用不可变对象所带来的一些效率提升也抵消了这种开销。例如：使用不可变对象降低了垃圾回收所产生的额外开销，也减少了用来确保使用可变对象不出现并发错误的一些额外代码。</p>
<p>接下来看一个可变对象的类，然后转化为一个不可变对象的类。通过这个例子说明转化的原则以及使用不可变对象的好处。</p>
<h3 id="一个同步类的例子"><a href="#一个同步类的例子" class="headerlink" title="一个同步类的例子"></a>一个同步类的例子</h3><p>SynchronizedRGB 是表示颜色的类，每一个对象代表一种颜色，使用三个整形数表示颜色的三基色，字符串表示颜色名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRGB</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Values must be between 0 and 255.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> red;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> green;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> blue;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> blue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (red &lt; <span class="number">0</span> || red &gt; <span class="number">255</span></span><br><span class="line">            || green &lt; <span class="number">0</span> || green &gt; <span class="number">255</span></span><br><span class="line">            || blue &lt; <span class="number">0</span> || blue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedRGB</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String name)</span> </span>&#123;</span><br><span class="line">        check(red, green, blue);</span><br><span class="line">        <span class="keyword">this</span>.red = red;</span><br><span class="line">        <span class="keyword">this</span>.green = green;</span><br><span class="line">        <span class="keyword">this</span>.blue = blue;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                    String name)</span> </span>&#123;</span><br><span class="line">        check(red, green, blue);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.red = red;</span><br><span class="line">            <span class="keyword">this</span>.green = green;</span><br><span class="line">            <span class="keyword">this</span>.blue = blue;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getRGB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((red &lt;&lt; <span class="number">16</span>) | (green &lt;&lt; <span class="number">8</span>) | blue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        red = <span class="number">255</span> - red;</span><br><span class="line">        green = <span class="number">255</span> - green;</span><br><span class="line">        blue = <span class="number">255</span> - blue;</span><br><span class="line">        name = <span class="string">&quot;Inverse of &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 SynchronizedRGB 时需要小心，避免其处于不一致的状态。例如一个线程执行了以下代码：</p>
<pre><code>SynchronizedRGB color =
    new SynchronizedRGB(0, 0, 0, &quot;Pitch Black&quot;);
...
int myColorInt = color.getRGB();      //Statement 1
String myColorName = color.getName(); //Statement 2</code></pre>
<p>如果有另外一个线程在 Statement 1 之后、Statement 2 之前调用了 color.set 方法，那么 myColorInt 的值和 myColorName 的值就会不匹配。为了避免出现这样的结果，必须要像下面这样把这两条语句绑定到一块执行：</p>
<pre><code>synchronized (color) &#123;
    int myColorInt = color.getRGB();
    String myColorName = color.getName();
&#125; </code></pre>
<p>这种不一致的问题只可能发生在可变对象上。</p>
<h3 id="定义不可变对象的策略"><a href="#定义不可变对象的策略" class="headerlink" title="定义不可变对象的策略"></a>定义不可变对象的策略</h3><p>以下的一些创建不可变对象的简单策略。并非所有不可变类都完全遵守这些规则，不过这不是编写这些类的程序员们粗心大意造成的，很可能的是他们有充分的理由确保这些对象在创建后不会被修改。但这需要非常复杂细致的分析，并不适用于初学者。</p>
<ul>
<li>不要提供 setter 方法。（包括修改字段的方法和修改字段引用对象的方法）</li>
<li>将类的所有字段定义为 final、private 的。</li>
<li>不允许子类重写方法。简单的办法是将类声明为 final，更好的方法是将构造函数声明为私有的，通过工厂方法创建对象。</li>
<li>如果类的字段是对可变对象的引用，不允许修改被引用对象。<ul>
<li>不提供修改可变对象的方法。</li>
<li>不共享可变对象的引用。当一个引用被当做参数传递给构造函数，而这个引用指向的是一个外部的可变对象时，一定不要保存这个引用。如果必须要保存，那么创建可变对象的拷贝，然后保存拷贝对象的引用。同样如果需要返回内部的可变对象时，不要返回可变对象本身，而是返回其拷贝。</li>
</ul>
</li>
</ul>
<p>将这一策略应用到 SynchronizedRGB 有以下几步：</p>
<ul>
<li>SynchronizedRGB 类有两个 setter 方法。第一个 set 方法只是简单的为字段设值，第二个 invert 方法修改为创建一个新对象，而不是在原有对象上修改。</li>
<li>所有的字段都已经是私有的，加上 final 即可。</li>
<li>将类声明为 final 的</li>
<li>只有一个字段是对象引用，并且被引用的对象也是不可变对象。</li>
</ul>
<p>经过以上这些修改后，我们得到了 ImmutableRGB：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableRGB</span> </span>&#123;</span><br><span class="line">	  <span class="comment">// Values must be between 0 and 255.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> red;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> green;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> blue;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> blue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (red &lt; <span class="number">0</span> || red &gt; <span class="number">255</span></span><br><span class="line">            || green &lt; <span class="number">0</span> || green &gt; <span class="number">255</span></span><br><span class="line">            || blue &lt; <span class="number">0</span> || blue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableRGB</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String name)</span> </span>&#123;</span><br><span class="line">        check(red, green, blue);</span><br><span class="line">        <span class="keyword">this</span>.red = red;</span><br><span class="line">        <span class="keyword">this</span>.green = green;</span><br><span class="line">        <span class="keyword">this</span>.blue = blue;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRGB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((red &lt;&lt; <span class="number">16</span>) | (green &lt;&lt; <span class="number">8</span>) | blue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableRGB <span class="title">invert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableRGB(<span class="number">255</span> - red,</span><br><span class="line">                       <span class="number">255</span> - green,</span><br><span class="line">                       <span class="number">255</span> - blue,</span><br><span class="line">                       <span class="string">&quot;Inverse of &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Socket</title>
    <url>/2020/09/30/Socket/</url>
    <content><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="什么是-Socket"><a href="#什么是-Socket" class="headerlink" title="什么是 Socket"></a>什么是 Socket</h2><p>Socket（套接字）：是在网络上运行两个程序之间的双向通信链路的一个端点。socket绑定到一个端口号，使得 TCP 层可以标识数据最终要被发送到哪个应用程序。</p>
<a id="more"></a>

<p>正常情况下，一台服务器在特定计算机上运行，​​并具有被绑定到特定端口号的 socket。服务器只是等待，并监听用于客户发起的连接请求的 socket 。</p>
<p>在客户端：客户端知道服务器所运行的主机名称以及服务器正在侦听的端口号。建立连接请求时，客户端尝试与主机服务器和端口会合。客户端也需要在连接中将自己绑定到本地端口以便于给服务器做识别。本地端口号通常是由系统分配的。</p>
<p><img src="../images/net/5connect.gif"></p>
<p>如果一切顺利的话，服务器接受连接。一旦接受，服务器获取绑定到相同的本地端口的新 socket ，并且还具有其远程端点设定为客户端的地址和端口。它需要一个新的socket，以便它可以继续监听原来用于客户端连接请求的 socket 。</p>
<p><img src="../images/net/6connect.gif"></p>
<p>在客户端，如果连接被接受，则成功地创建一个套接字和客户端可以使用该 socket 与服务器进行通信。</p>
<p>客户机和服务器现在可以通过 socket 写入或读取来交互了。</p>
<p>端点是IP地址和端口号的组合。每个 TCP 连接可以通过它的两个端点被唯一标识。这样，你的主机和服务器之间可以有多个连接。</p>
<p>java.net 包中提供了一个类 Socket，实现您的 Java 程序和网络上的其他程序之间的双向连接。 Socket 类隐藏任何特定系统的细节。通过使用 java.net.Socket 类，而不是依赖于原生代码，Java 程序可以用独立于平台的方式与网络进行通信。</p>
<p>此外，java.net 包含了 ServerSocket 类，它实现了服务器的 socket 可以侦监听和接受客户端的连接。下文将展示如何使用 Socket 和 ServerSocket 类。</p>
<h2 id="实现一个-echo-服务器"><a href="#实现一个-echo-服务器" class="headerlink" title="实现一个 echo 服务器"></a>实现一个 echo 服务器</h2><p>让我们来看看这个例子，程序可以建立使用 Socket 类连接到服务器程序，客户端可以通过 socket 向服务器发送数据和接收数据。</p>
<p>EchoClient 示例程序实现了一个客户端，连接到回声服务器。回声服务器从它的客户端接收数据并原样返回回来。EchoServer 实现了 echo 服务器。 （客户端可以连接到支持 <a href="http://tools.ietf.org/html/rfc862">Echo 协议</a>的任何主机）</p>
<p>EchoClient 创建一个 socket，从而得到回声服务器的连接。它从标准输入流中读取用户输入，然后通过 socket 转发该文本给回声服务器。服务器通过该 socket 将文本原样输入回给客户端。客户机程序读取并显示从服务器传递回给它的数据。</p>
<p>注意，EchoClient 例子既从 socket 写入又从 socket 中读取数据。</p>
<p>EchoClient 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">            System.err.println(</span><br><span class="line">                <span class="string">&quot;Usage: java EchoClient &lt;host name&gt; &lt;port number&gt;&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String hostName = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> portNumber = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            Socket echoSocket = <span class="keyword">new</span> Socket(hostName, portNumber);</span><br><span class="line">            PrintWriter out =</span><br><span class="line">                <span class="keyword">new</span> PrintWriter(echoSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">            BufferedReader in =</span><br><span class="line">                <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(echoSocket.getInputStream()));</span><br><span class="line">            BufferedReader stdIn =</span><br><span class="line">                <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(System.in))</span><br><span class="line">        ) &#123;</span><br><span class="line">            String userInput;</span><br><span class="line">            <span class="keyword">while</span> ((userInput = stdIn.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.println(userInput);</span><br><span class="line">                System.out.println(<span class="string">&quot;echo: &quot;</span> + in.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Don&#x27;t know about host &quot;</span> + hostName);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Couldn&#x27;t get I/O for the connection to &quot;</span> +</span><br><span class="line">                hostName);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EchoServer 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage: java EchoServer &lt;port number&gt;&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> portNumber = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            ServerSocket serverSocket =</span><br><span class="line">                <span class="keyword">new</span> ServerSocket(Integer.parseInt(args[<span class="number">0</span>]));</span><br><span class="line">            Socket clientSocket = serverSocket.accept();     </span><br><span class="line">            PrintWriter out =</span><br><span class="line">                <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);                   </span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        ) &#123;</span><br><span class="line">            String inputLine;</span><br><span class="line">            <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.println(inputLine);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception caught when trying to listen on port &quot;</span></span><br><span class="line">                + portNumber + <span class="string">&quot; or listening for a connection&quot;</span>);</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先启动服务器，在命令行输入如下，设定一个端口号，比如 7（Echo 协议指定端口是 7）：</p>
<pre><code>java EchoServer 7</code></pre>
<p>而后启动客户端，echoserver.example.com  是你主机的名称，如果是本机的话，主机名称可以是 localhost</p>
<pre><code>java EchoClient echoserver.example.com 7</code></pre>
<p>输出效果如下：</p>
<pre><code>你好吗？
echo: 你好吗？
我很好哦
echo: 我很好哦
要过年了，www.waylau.com 祝你 猴年大吉，身体健康哦！
echo: 要过年了，www.waylau.com 祝你 猴年大吉，身体健康哦！</code></pre>
]]></content>
  </entry>
  <entry>
    <title>异常链</title>
    <url>/2020/09/30/u%E5%BC%82%E5%B8%B8%E9%93%BE/</url>
    <content><![CDATA[<h1 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h1><p>应用程序通常会通过抛出另一个异常来响应异常。 实际上，第一个异常引起第二个异常。 它可以是非常有助于用户知道什么时候一个异常导致另一个异常。 “异常链（Chained Exceptions）”帮助程序员做到这一点。<a id="more"></a></p>
<p>以下是Throwable中支持异常链的方法和构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Throwable <span class="title">getCause</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Throwable <span class="title">initCause</span><span class="params">(Throwable)</span></span></span><br><span class="line"><span class="function"><span class="title">Throwable</span><span class="params">(String, Throwable)</span></span></span><br><span class="line"><span class="function"><span class="title">Throwable</span><span class="params">(Throwable)</span></span></span><br></pre></td></tr></table></figure>



<p>initCause和Throwable构造函数的Throwable参数是导致当前异常的异常。 getCause返回导致当前异常的异常，initCause设置当前异常的原因。</p>
<p>以下示例显示如何使用异常链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SampleException(<span class="string">&quot;Other IOException&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在此示例中，当捕获到IOException时，将创建一个新的SampleException异常，并附加原始的异常原因，并将异常链抛出到下一个更高级别的异常处理程序。</p>
<h2 id="访问堆栈跟踪信息"><a href="#访问堆栈跟踪信息" class="headerlink" title="访问堆栈跟踪信息"></a>访问堆栈跟踪信息</h2><p>现在让我们假设更高级别的异常处理程序想要以自己的格式转储堆栈跟踪。</p>
<p>定义：堆栈跟踪（stack trace）提供有关当前线程的执行历史的信息，并列出在异常发生时调用的类和方法的名称。 堆栈跟踪是一个有用的调试工具，通常在抛出异常时会利用它。</p>
<p>以下代码显示了如何在异常对象上调用getStackTrace方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Exception cause) &#123;</span><br><span class="line">    StackTraceElement elements[] = cause.getStackTrace();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = elements.length; i &lt; n; i++) &#123;       </span><br><span class="line">        System.err.println(elements[i].getFileName()</span><br><span class="line">            + <span class="string">&quot;:&quot;</span> + elements[i].getLineNumber() </span><br><span class="line">            + <span class="string">&quot;&gt;&gt; &quot;</span></span><br><span class="line">            + elements[i].getMethodName() + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日志-API"><a href="#日志-API" class="headerlink" title="日志 API"></a>日志 API</h2><p>如果要记录catch块中所发生异常，最好不要手动解析堆栈跟踪并将输出发送到 System.err()，而是使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/logging/package-summary.html">java.util.logging</a>包中的日志记录工具将输出发送到文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Handler handler = <span class="keyword">new</span> FileHandler(<span class="string">&quot;OutFile.log&quot;</span>);</span><br><span class="line">    Logger.getLogger(<span class="string">&quot;&quot;</span>).addHandler(handler);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    Logger logger = Logger.getLogger(<span class="string">&quot;package.name&quot;</span>); </span><br><span class="line">    StackTraceElement elements[] = e.getStackTrace();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = elements.length; i &lt; n; i++) &#123;</span><br><span class="line">        logger.log(Level.WARNING, elements[i].getMethodName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>使用异常带来的优势</title>
    <url>/2020/09/30/%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BC%98%E5%8A%BF/</url>
    <content><![CDATA[<h1 id="使用异常带来的优势"><a href="#使用异常带来的优势" class="headerlink" title="使用异常带来的优势"></a>使用异常带来的优势</h1><p>现在你知道什么是异常，以及如何使用它们，现在是时候了解在程序中使用异常的优点。</p>
<a id="more"></a>
<h2 id="优点1：将错误处理代码与“常规”代码分离"><a href="#优点1：将错误处理代码与“常规”代码分离" class="headerlink" title="优点1：将错误处理代码与“常规”代码分离"></a>优点1：将错误处理代码与“常规”代码分离</h2><p>异常提供了一种方法来分离当一个程序的主逻辑发生异常情况时应该做什么的细节。 在传统的编程中，错误检测、报告和处理常常导致混淆意大利面条代码（spaghetti code）。 例如，考虑这里的伪代码方法将整个文件读入内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readFile &#123;</span><br><span class="line">    open the file;</span><br><span class="line">    determine its size;</span><br><span class="line">    allocate that much memory;</span><br><span class="line">    read the file into memory;</span><br><span class="line">    close the file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，这个功能看起来很简单，但它忽略了以下所有潜在错误。</p>
<ul>
<li>如果无法打开文件会发生什么？</li>
<li>如果无法确定文件的长度，会发生什么？</li>
<li>如果不能分配足够的内存，会发生什么？</li>
<li>如果读取失败会发生什么？</li>
<li>如果文件无法关闭会怎么样？</li>
</ul>
<p>为了处理这种情况，readFile函数必须有更多的代码来执行错误检测\报告和处理。 这里是一个示例，来展示该函数可能会是什么样子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">errorCodeType readFile &#123;</span><br><span class="line">    initialize errorCode = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    open the file;</span><br><span class="line">    <span class="keyword">if</span> (theFileIsOpen) &#123;</span><br><span class="line">        determine the length of the file;</span><br><span class="line">        <span class="keyword">if</span> (gotTheFileLength) &#123;</span><br><span class="line">            allocate that much memory;</span><br><span class="line">            <span class="keyword">if</span> (gotEnoughMemory) &#123;</span><br><span class="line">                read the file into memory;</span><br><span class="line">                <span class="keyword">if</span> (readFailed) &#123;</span><br><span class="line">                    errorCode = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                errorCode = -<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errorCode = -<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        close the file;</span><br><span class="line">        <span class="keyword">if</span> (theFileDidntClose &amp;&amp; errorCode == <span class="number">0</span>) &#123;</span><br><span class="line">            errorCode = -<span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errorCode = errorCode and -<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errorCode = -<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errorCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面会有很多错误检测、报告的细节，使得原来的七行代码被淹没在这杂乱的代码中。 更糟的是，代码的逻辑流也已经丢失，因此很难判断代码是否正确：如果函数无法分配足够的内存，文件是否真的被关闭？ 在编写方法三个月后修改方法时，更难以确保代码能够继续正确的操作。 因此，许多程序员通过简单地忽略它来解决这个问题。这样当他们的程序崩溃时，就生成了报告错误。</p>
<p>异常使您能够编写代码的主要流程，并处理其他地方的特殊情况。 如果readFile函数使用异常而不是传统的错误管理技术，它将看起来更像下面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readFile &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        open the file;</span><br><span class="line">        determine its size;</span><br><span class="line">        allocate that much memory;</span><br><span class="line">        read the file into memory;</span><br><span class="line">        close the file;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (fileOpenFailed) &#123;</span><br><span class="line">       doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (sizeDeterminationFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (memoryAllocationFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (readFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (fileCloseFailed) &#123;</span><br><span class="line">        doSomething;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>请注意，异常不会减少你在法执行检测、报告和处理错误方面的工作，但它们可以帮助您更有效地组织工作。</p>
<h2 id="优点2：将错误沿调用推栈向上传递"><a href="#优点2：将错误沿调用推栈向上传递" class="headerlink" title="优点2：将错误沿调用推栈向上传递"></a>优点2：将错误沿调用推栈向上传递</h2><p>异常的第二个优点是能够在方法的调用堆栈上将错误向上传递。 假设 readFile 方法是由主程序进行的一系列嵌套方法调用中的第四个方法：method1调用method2，它调用了method3，最后调用readFile。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method1 &#123;</span><br><span class="line">    call method2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method2 &#123;</span><br><span class="line">    call method3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method3 &#123;</span><br><span class="line">    call readFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还假设method1是对readFile中可能发生的错误感兴趣的唯一方法。 传统的错误通知技术强制method2和method3将readFile返回的错误代码传递到调用堆栈，直到错误代码最终到达method1 - 对它们感兴趣的唯一方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method1 &#123;</span><br><span class="line">    errorCodeType error;</span><br><span class="line">    error = call method2;</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        doErrorProcessing;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        proceed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errorCodeType method2 &#123;</span><br><span class="line">    errorCodeType error;</span><br><span class="line">    error = call method3;</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        proceed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errorCodeType method3 &#123;</span><br><span class="line">    errorCodeType error;</span><br><span class="line">    error = call readFile;</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回想一下，Java运行时环境通过调用堆栈向后搜索以找到任何对处理特定异常感兴趣的方法。 一个方法可以阻止在其中抛出的任何异常，从而允许一个方法在调用栈上更远的地方来捕获它。 因此，只有关心错误的方法才需要担心检测错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method1 &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        call method2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception e) &#123;</span><br><span class="line">        doErrorProcessing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method2 <span class="keyword">throws</span> exception &#123;</span><br><span class="line">    call method3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method3 <span class="keyword">throws</span> exception &#123;</span><br><span class="line">    call readFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，如伪代码所示，抛弃异常需要中间人方法的一些努力。 任何可以在方法中抛出的已检查异常都必须在其throws子句中指定。</p>
<h2 id="优点3：对错误类型进行分组和区分"><a href="#优点3：对错误类型进行分组和区分" class="headerlink" title="优点3：对错误类型进行分组和区分"></a>优点3：对错误类型进行分组和区分</h2><p>因为在程序中抛出的所有异常都是对象，异常的分组或分类是类层次结构的自然结果。 Java平台中一组相关异常类的示例是java.io - IOException中定义的那些异常类及其后代。 IOException是最常见的，表示执行I/O时可能发生的任何类型的错误。 它的后代表示更具体的错误。 例如，FileNotFoundException意味着文件无法在磁盘上找到。</p>
<p>一个方法可以编写可以处理非常特定异常的特定处理程序。 FileNotFoundException类没有后代，因此下面的处理程序只能处理一种类型的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法可以通过在catch语句中指定任何异常的超类来基于其组或常规类型捕获异常。 例如，为了捕获所有I/O异常，无论其具体类型如何，异常处理程序都会指定一个IOException参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个处理程序将能够捕获所有I/O异常，包括FileNotFoundException、EOFException等等。 您可以通过查询传递给异常处理程序的参数来查找有关发生的详细信息。 例如，使用以下命令打印堆栈跟踪。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// Output goes to System.err.</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">// Send trace to stdout.</span></span><br><span class="line">    e.printStackTrace(System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面例子可以处理所有的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A (too) general exception handler</span></span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Exception 类接近Throwable类层次结构的顶部。因此，这个处理程序将会捕获除处理程序想要捕获的那些异常之外的许多其他异常。在程序中如果是以这种方式来处理异常，那么你程序一般的做法就是，例如，是打印出一个错误消息给用户，然后退出。</p>
<p>在大多数情况下，异常处理程序应该尽可能的具体。原因是处理程序必须做的第一件事是在选择最佳恢复策略之前，首先要确定发生的是什么类型的异常。实际上，如果不捕获特定的错误，处理程序必须适应任何可能性。太过通用的异常处理程序可能会捕获和处理程序员不期望的并且处理程序不想要的异常，从而使代码更容易出错。</p>
<p>如上所述，您可以以常规方式创建异常分组来处理异常，也可以使用特定的异常类型来区分异常从而可以以确切的方式来处理异常。</p>
]]></content>
  </entry>
  <entry>
    <title>关键字</title>
    <url>/2020/09/30/%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>下面是 Java 里面的关键字。不能使用以下任一作为您的程序标识符。关键字 const 和 goto 语句被保留，即使他们目前尚未使用。true, false, 和 null </p>
<a id="more"></a>
<p>似乎是关键字，但它们实际上是字面值;你不能使用它们作为你的程序标识符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract	continue	for	new	switch</span><br><span class="line">assert***	default	goto*	package	synchronized</span><br><span class="line">boolean	do	if	private	this</span><br><span class="line">break	double	implements	protected	throw</span><br><span class="line">byte	else	import	public	throws</span><br><span class="line">case	enum****	instanceof	return	transient</span><br><span class="line">catch	extends	int	short	try</span><br><span class="line">char	final	interface	static	void</span><br><span class="line">class	finally	long	strictfp**	volatile</span><br><span class="line">const*	float	native	super	while</span><br></pre></td></tr></table></figure>

<p>其中:<code>*</code>表示未使用，<code>**</code>表示是 1.2版本加入，<code>***</code>    表示 1.4版本加入，<br><code>****</code>    表示5.0版本加入</p>
]]></content>
  </entry>
  <entry>
    <title>创建异常类</title>
    <url>/2020/09/30/%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h1><p>当面对选择抛出异常的类型时，您可以使用由别人编写的异常 - Java平台提供了许多可以使用的异常类 - 或者您可以编写自己的异常类。 <a id="more"></a>如果您对任何以下问题回答“是”，您应该编写自己的异常类；否则，你可以使用别人的。</p>
<ul>
<li>你需要一个Java平台中没有表示的异常类型吗？</li>
<li>如果用户能够区分你的异常与由其他供应商编写的类抛出的异常吗？</li>
<li>你的代码是否抛出不止一个相关的异常？</li>
<li>如果您使用他人的例外，用户是否可以访问这些异常？ 一个类似的问题是你的包是独立只提供自己使用吗？</li>
</ul>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>假设你正在写一个链表类。该类支持以下方法：</p>
<ul>
<li>objectAt(int n) - 返回列表中第n个位置的对象。如果参数小于0或大于当前列表中的对象数，则抛出异常。</li>
<li>firstObject() - 返回列表中的第一个对象。如果列表不包含对象，则抛出异常。</li>
<li>indexOf(Object o) - 搜索指定对象的列表，并返回其在列表中的位置。如果传入方法的对象不在列表中，则抛出异常。</li>
</ul>
<p>链表类可以抛出多个异常，使用一个异常处理程序捕获链表所抛出的所有异常是很方便的。此外，如果您计划在包中分发链表，所有相关代码都应打包在一起。因此，链表应该提供自己的一组异常类。</p>
<p>下图说明了链表抛出的异常的一个可能的类层次结构。</p>
<p><img src="../images/exception/exceptions-hierarchy.gif"></p>
<h2 id="选择超类"><a href="#选择超类" class="headerlink" title="选择超类"></a>选择超类</h2><p>任何 Exception  子类都可以用作 LinkedListException 的父类。 然而，但这些子类有些专用的，有些又与 LinkedListException 完全无关。 因此，LinkedListException的父类应该是Exception。</p>
<p>你编写的大多数applet和应用程序都会抛出 Exception 对象。 Error 通常用于系统中严重的硬错误，例如阻止JVM运行的错误。</p>
<p>注意：对于可读代码，最好将字符串Exception附加到从异常类继承（直接或间接）的所有类的名称。</p>
]]></content>
  </entry>
  <entry>
    <title>如何抛出异常</title>
    <url>/2020/09/30/%E5%A6%82%E4%BD%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h1><p>在你可以捕获异常之前，一些代码必须抛出一个异常。任何代码都可能会抛出异常：您的代码，来自其他人编写的包（例如Java平台附带的包）或Java运行时环境的代码。无论是什么引发的异常，它总是通过 throw 语句抛出。<a id="more"></a></p>
<p>您可能已经注意到，Java平台提供了许多异常类。所有类都是Throwable类的后代，并且都允许程序区分在程序执行期间可能发生的各种类型的异常。</p>
<p>您还可以创建自己的异常类来表示在您编写的类中可能发生的问题。事实上，如果您是包开发人员，您可能必须创建自己的一组异常类，以允许用户区分包中可能发生的错误与Java平台或其他包中发生的错误。</p>
<p>您还可以创建异常链。有关更多信息，请参阅“异常链”部分。</p>
<h2 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h2><p>所有方法都使用throw语句抛出异常。 throw语句需要一个参数：throwable 对象。 Throwable 对象是Throwable类的任何子类的实例。 这里是一个throw 语句的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> someThrowableObject;</span><br></pre></td></tr></table></figure>

<p>让我们来看一下上下文中的throw语句。 以下pop方法取自实现公共堆栈对象的类。 该方法从堆栈中删除顶层元素并返回对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj = objectAt(size - <span class="number">1</span>);</span><br><span class="line">    setObjectAt(size - <span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pop 方法将会检查栈中的元素。如果栈是空的（它的size等于0），则pop实例化一个 EmptyStackException对象（java.util的成员）并抛出它。 本章中的“创建异常类”部分介绍如何创建自己的异常类。 现在，所有你需要记住的是，你可以只抛出继承自java.lang.Throwable类的对象。</p>
<p>注意，pop方法的声明不包含throws子句。 EmptyStackException不是已检查异常，因此不需要pop来声明它可能发生。</p>
<h3 id="Throwable类及其子类"><a href="#Throwable类及其子类" class="headerlink" title="Throwable类及其子类"></a>Throwable类及其子类</h3><p>继承自Throwable类的对象包括直接后代（直接从Throwable类继承的对象）和间接后代（从Throwable类的子代或孙代继承的对象）。 下图说明了Throwable类及其最重要的子类的类层次结构。 正如你所看到的，Throwable有两个直接的后代：Error和Exception。</p>
<p><img src="../images/exception/exceptions-throwable.gif"></p>
<h3 id="Error-类"><a href="#Error-类" class="headerlink" title="Error 类"></a>Error 类</h3><p>当Java虚拟机中发生动态链接故障或其他硬故障时，虚拟机会抛出 Error。简单的程序通常不捕获或抛出Error。</p>
<h3 id="Exception-类"><a href="#Exception-类" class="headerlink" title="Exception 类"></a>Exception 类</h3><p>大多数程序抛出和捕获从 Exception 类派生的对象。Exception 表示发生了问题，但它不是严重的系统问题。你编写的大多数程序将抛出并捕获Exception而不是 Error。</p>
<p>Java平台定义了 Exception  类的许多后代。这些后代表示可能发生的各种类型的异常。例如，IllegalAccessException表示找不到特定方法，NegativeArraySizeException表示程序尝试创建一个负大小的数组。</p>
<p>一个 Exception 子类RuntimeException保留用于指示不正确使用API​​的异常。运行时异常的一个示例是NullPointerException，当方法尝试通过空引用访问对象的成员时，会发生此异常。“未检查异常”章节讨论了为什么大多数应用程序不应该抛出运行时异常或RuntimeException的子类。</p>
]]></content>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2020/09/30/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在Java语言中，是使用“异常（exception）”来处理错误及其他异常事件。术语“异常”是短语“异常事件（exceptional event）”的缩写。</p>
<a id="more"></a>

<p><strong>异常</strong>是在程序执行期间发生的事件，它会中断程序指令的正常流程。</p>
<p>当在方法中发生错误时，该方法创建一个对象并将其移交给运行时系统。 该对象称为“异常对象（exception object）”，包含有关错误的信息，包括错误发生时其类型和程序的状态。 创建异常对象并将其移交给运行时系统，这个过程被称为“抛出异常（throwing an exception）”。</p>
<p>在方法抛出异常后，运行时系统会尝试寻找一些方式来处理它。 这个方法列表被叫做“调用堆栈（call　stack）”，调用方式如下图所示（参见下图）。</p>
<p><img src="../images/exception/exceptions-callstack.gif"></p>
<p>运行时系统搜寻包含能够处理异常的代码块的方法所请求的堆栈。这个代码块叫做“异常处理器（ exception handler）”，搜寻首先从发生的方法开始，然后依次按着调用方法的倒序检索调用堆栈。当找到一个相应的处理器时，运行时系统就把异常传递给这个处理器。一个异常处理器要适当地考虑抛出的异常对象的类型与异常处理器所处理的异常的类型是否匹配。</p>
<p>当异常处理器被选中时，称为“捕获异常（catch the exception）”。异常被捕获以后，异常处理器关闭。如果运行时系统搜寻了这个方法的所有调用堆栈，而没有找到相应的异常处理器，如下图所示，运行进系统将终止执行。</p>
<p><img src="../images/exception/exceptions-errorOccurs.gif"></p>
<p>使用异常来管理错误比传统的错误管理技术有一些优势。见“<a href="exceptions-advantages.md">使用异常带来的优势</a>”一节。</p>
]]></content>
  </entry>
  <entry>
    <title>并发</title>
    <url>/2020/09/30/%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>计算机用户想当然地认为他们的系统在一个时间可以做多件事。他们认为，他们可以工作在一个字处理器，而其他应用程序在下载文件，管理打印队列和音频流。即使是单一的应用程序通常也是被期望在一个时间来做多件事。</p>
<a id="more"></a>例如，音频流应用程序必须同时读取数字音频，解压，管理播放，并更新显示。即使字处理器应该随时准备响应键盘和鼠标事件，不管多么繁忙，它总是能格式化文本或更新显示。可以做这样的事情的软件称为并发软件（concurrent software）。

<p>在 Java 平台是完全支持并发编程。自从 5.0 版本以来，这个平台还包括高级并发 API, 主要集中在 java.util.concurrent 包。</p>
]]></content>
  </entry>
  <entry>
    <title>异常捕获与处理</title>
    <url>/2020/09/30/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="异常捕获与处理"><a href="#异常捕获与处理" class="headerlink" title="异常捕获与处理"></a>异常捕获与处理</h1><p>本节介绍如何使用三个异常处理程序组件（try、catch 和 finally）来编写异常处理程序。 然后，介绍了 Java SE 7中引入的 try-with-resources 语句。 try-with-resources 语句特别适合于使用<code>Closeable</code>的资源（例如流）的情况。</p>
<a id="more"></a>

<p>本节的最后一部分将通过一个示例来分析在各种情况下发生的情况。</p>
<p>以下示例定义并实现了一个名为ListOfNumbers的类。 构造时，ListOfNumbers 创建一个ArrayList，其中包含10个序列值为0到9的整数元素。ListOfNumbers类还定义了一个名为writeList的方法，该方法将数列表写入一个名为<code>OutFile.txt</code>的文本文件中。 此示例使用在<code>java.io</code>中定义的输出类，这些类包含在基本I/O中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Note: This class will not compile yet.</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfNumbers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListOfNumbers</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(SIZE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Integer(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// The FileWriter constructor throws IOException, which must be caught.</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;OutFile.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            <span class="comment">// The get(int) method throws IndexOutOfBoundsException, which must be caught.</span></span><br><span class="line">            out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>构造函数 FileWriter 初始化文件上的输出流。如果文件无法打开，构造函数会抛出一个IOException异常。第二个对ArrayList类的get方法的调用，如果其参数的值太小（小于0）或太大（超过ArrayList当前包含的元素数量），它将抛出 IndexOutOfBoundsException。</p>
<p>如果尝试编译ListOfNumbers类，则编译器将打印有关FileWriter构造函数抛出的异常的错误消息。但是，它不显示有关get抛出的异常的错误消息。原因是构造函数IOException抛出的异常是一个检查异常，而get方法IndexOutOfBoundsException抛出的异常是未检查的异常。</p>
<p>现在，我们已经熟悉ListOfNumbers类，并且知道了其中那些地方可能抛出异常。下一步我们就可以编写异常处理程序来捕获和处理这些异常。</p>
<h2 id="try块"><a href="#try块" class="headerlink" title="try块"></a>try块</h2><p>构造异常处理程序的第一步是封装可能在try块中抛出异常的代码。 一般来说，try块看起来像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    code</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> and <span class="keyword">finally</span> blocks . . .</span><br></pre></td></tr></table></figure>

<p>示例标记 <code>code</code> 中的段可以包含一个或多个可能抛出的异常。</p>
<p>每行可能抛出异常的代码都可以用单独的一个 try 块，或者多个异常放置在一个 try 块中。 以下示例由于非常简短，所有使用一个try块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Entered try statement&quot;</span>);</span><br><span class="line">        out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;OutFile.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> and <span class="keyword">finally</span> blocks  . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果在try块中发生异常，那么该异常由与其相关联的异常处理程序将会进行处理。 要将异常处理程序与try块关联，必须在其后面放置一个catch块。</p>
<h2 id="catch块"><a href="#catch块" class="headerlink" title="catch块"></a>catch块</h2><p>通过在try块之后直接提供一个或多个catch块，可以将异常处理程序与try块关联。 在try块的结尾和第一个catch块的开始之间没有代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType name) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType name) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>每个catch块是一个异常处理程序，处理由其参数指示的异常类型。 参数类型ExceptionType声明了处理程序可以处理的异常类型，并且必须是从Throwable类继承的类的名称。 处理程序可以使用名称引用异常。</p>
<p>catch块包含了在调用异常处理程序时执行的代码。 当处理程序是调用堆栈中第一个与ExceptionType匹配的异常抛出的类型时，运行时系统将调用异常处理程序。 如果抛出的对象可以合法地分配给异常处理程序的参数，则系统认为它是匹配。</p>
<p>以下是writeList方法的两个异常处理程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;IndexOutOfBoundsException: &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Caught IOException: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理程序可以做的不仅仅是打印错误消息或停止程序。 它们可以执行错误恢复，提示用户做出决定，或者使用异常链将错误传播到更高级别的处理程序，如“异常链”部分所述。</p>
<h3 id="在一个异常处理程序中处理多个类型的异常"><a href="#在一个异常处理程序中处理多个类型的异常" class="headerlink" title="在一个异常处理程序中处理多个类型的异常"></a>在一个异常处理程序中处理多个类型的异常</h3><p>在Java SE 7和更高版本中，单个catch块可以处理多种类型的异常。 此功能可以减少代码重复，并减少定义过于宽泛的异常。</p>
<p>在catch子句中，多个类型的异常使用竖线（|）分隔每个异常类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException|SQLException ex) &#123;</span><br><span class="line">    logger.log(ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果catch块处理多个异常类型，则catch参数将隐式为final。 在本示例中，catch参数ex是final，因此您不能在catch块中为其分配任何值。</p>
<h2 id="finally-块"><a href="#finally-块" class="headerlink" title="finally 块"></a>finally 块</h2><p>finally块总是在try块退出时执行。这确保即使发生意外异常也会执行finally块。但 finally 的用处不仅仅是异常处理 - 它允许程序员避免清理代码意外绕过 return、continue 或 break 。将清理代码放在finally块中总是一个好的做法，即使没有预期的异常。</p>
<p>注意：如果在执行try或catch代码时JVM退出，则finally块可能无法执行。同样，如果执行try或catch代码的线程被中断或杀死，则finally块可能不执行，即使应用程序作为一个整体继续。</p>
<p>writeList方法的try块打开一个PrintWriter。程序应该在退出writeList方法之前关闭该流。这提出了一个有点复杂的问题，因为writeList的try块可以以三种方式中的一种退出。</p>
<ul>
<li>new FileWriter语句失败并抛出IOException。</li>
<li>list.get(i)语句失败，并抛出IndexOutOfBoundsException。</li>
<li>一切成功，try块正常退出。</li>
</ul>
<p>运行时系统总是执行finally块内的语句，而不管try块内发生了什么。所以它是执行清理的完美场所。</p>
<p>下面的finally块为writeList方法清理，然后关闭PrintWriter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Closing PrintWriter&quot;</span>);</span><br><span class="line">        out.close(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;PrintWriter not open&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>重要：finally块是防止资源泄漏的关键工具。 当关闭文件或恢复资源时，将代码放在finally块中，以确保资源始终恢复。</p>
<p>考虑在这些情况下使用try-with-resources语句，当不再需要时自动释放系统资源。 </p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本章例子的源码，可以在 <a href="https://github.com/waylau/essential-java">https://github.com/waylau/essential-java</a> 中 <code>com.waylau.essentialjava.exception</code> 包下找到。</p>
<h2 id="try-with-resources-语句"><a href="#try-with-resources-语句" class="headerlink" title="try-with-resources 语句"></a>try-with-resources 语句</h2><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html">java.lang.AutoCloseable</a> 接口（其中，它包括实现了 <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html">java.io.Closeable</a> 的所有对象），可以使用作为资源。</p>
<p>例如，我们自定义一个资源类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Resource res = <span class="keyword">new</span> Resource()) &#123;</span><br><span class="line">            res.doSome();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;resource is closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出如下：</p>
<pre><code>do something
resource is closed</code></pre>
<p>可以看到，资源终止被自动关闭了。</p>
<p>再来看一个例子，是同时关闭多个资源的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(ResourceSome some = <span class="keyword">new</span> ResourceSome();</span><br><span class="line">             ResourceOther other = <span class="keyword">new</span> ResourceOther()) &#123;</span><br><span class="line">            some.doSome();</span><br><span class="line">            other.doOther();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceSome</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;some resource is closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceOther</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doOther</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do other things&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;other resource is closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出为：</p>
<pre><code>do something
do other things
other resource is closed
some resource is closed</code></pre>
<p>在 try 语句中越是最后使用的资源，越是最早被关闭。</p>
<h3 id="try-with-resources-在-JDK-9-中的改进"><a href="#try-with-resources-在-JDK-9-中的改进" class="headerlink" title="try-with-resources 在 JDK 9 中的改进"></a>try-with-resources 在 JDK 9 中的改进</h3><p>作为 <a href="http://openjdk.java.net/jeps/213">Milling Project Coin</a> 的一部分, try-with-resources 声明在 JDK 9  已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p>
<p>例如,给定资源的声明</p>
<pre><code>// A final resource
final Resource resource1 = new Resource(&quot;resource1&quot;);
// An effectively final resource
Resource resource2 = new Resource(&quot;resource2&quot;);</code></pre>
<p>老方法编写代码来管理这些资源是类似的:</p>
<pre><code>// Original try-with-resources statement from JDK 7 or 8
try (Resource r1 = resource1;
     Resource r2 = resource2) &#123;
    // Use of resource1 and resource 2 through r1 and r2.
&#125;</code></pre>
<p>而新方法可以是</p>
<pre><code>// New and improved try-with-resources statement in JDK 9
try (resource1;
     resource2) &#123;
    // Use of resource1 and resource 2.
&#125;</code></pre>
<p>看上去简洁很多吧。对 Java 未来的发展信心满满。</p>
<p>愿意尝试 JDK 9 这种新语言特性的可以下载使用 <a href="https://jdk9.java.net/download/">JDK 9 快照</a>。Enjoy!</p>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p>本章例子的源码，可以在 <a href="https://github.com/waylau/essential-java">https://github.com/waylau/essential-java</a> 中 <code>com.waylau.essentialjava.exception.trywithresources</code> 包下找到。</p>
]]></content>
  </entry>
  <entry>
    <title>未检查异常</title>
    <url>/2020/09/30/%E6%9C%AA%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="未检查异常"><a href="#未检查异常" class="headerlink" title="未检查异常"></a>未检查异常</h1><p>因为Java编程语言不需要捕获方法或声明未检查异常（包括 RuntimeException、Error及其子类），<a id="more"></a>程序员可能会试图编写只抛出未检查异常的代码，或使所有异常子类继承自RuntimeException。这两个快捷方式都允许程序员编写代码，而不必担心编译器错误，也不用担心声明或捕获任何异常。虽然这对于程序员似乎很方便，但它避开了捕获或者声明异常的需求，并且可能会导致其他人在使用您的类而产生问题。</p>
<p>为什么设计人员决定强制一个方法来指定所有可以抛出的未捕获的已检查异常？任何可以由方法抛出的 Exception 都是方法的公共编程接口的一部分。调用方法的人必须知道一个方法可以抛出的异常，以便他们可以决定如何处理它们。这些异常是该方法的编程接口的一部分，作为它的参数和 return 值。</p>
<p>下一个问题可能是：“既然一个方法的API已经做好了很好的记录，包括它可以抛出的异常，为什么不指定运行时异常？”运行时异常展示的是编程问题的结果，因此，API用户可能会用不合理方式来处理它们。这样就有可能产生问题，包括算术异常，例如除以零;指针异常，例如试图通过空引用访问对象;索引异常，例如尝试通过太大或太小的索引访问数组元素。</p>
<p>运行时异常可能发生在程序中的任何地方，在典型的程序中它们可以非常多。必须在每个方法声明中添加运行时异常则会降低程序的清晰度。因此，编译器不需要捕获或声明运行时异常（尽管可以是可以做到）。</p>
<p>一种情况是，通常的做法是当用户调用一个方法不正确时，抛出一个RuntimeException。例如，一个方法可以检查其中一个参数是否不正确为null。如果参数为null，那么该方法可能会抛出NullPointerException异常，这是一个未检查异常。</p>
<p>一般来说，不要抛出一个RuntimeException或创建一个RuntimeException的子类，这样你就不会被声明哪些方法可以抛出的异常所困扰。</p>
<p>一个底线原则是：如果客户端可以合理地从期望异常中恢复，那么使其成为一个已检查异常。如果客户端无法从异常中恢复，请将其设置为未检查异常。</p>
]]></content>
  </entry>
  <entry>
    <title>注解</title>
    <url>/2020/09/30/%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="注解（Annotations）"><a href="#注解（Annotations）" class="headerlink" title="注解（Annotations）"></a>注解（Annotations）</h1><p>注解为程序提供元数据（metadata）.元数据又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息。它不会影响程序的编译方式，也不会影响最终的编译结果。</p>
<a id="more"></a>

<p>注解有如下的使用场景：</p>
<ul>
<li>编译器信息— 编译器用注解检测到错误或抑制警告。</li>
<li>编译时和部署时的处理 — 软件工具可以处理注释的信息来生成代码，XML文件，等等。</li>
<li>运行时处理 — 有些注解是在运行时进行检查.</li>
</ul>
<h2 id="注解的格式"><a href="#注解的格式" class="headerlink" title="注解的格式"></a>注解的格式</h2><p>注解的格式的通常拥有键/值对，其键就是方法名。<br>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br></pre></td></tr></table></figure>

<p>符号<code>@</code>告诉编译器这是个注解。</p>
<p>注解可以包含有名字或者没有名字的元素（elements），如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Author(</span><br><span class="line">   name &#x3D; &quot;Benjamin Franklin&quot;,</span><br><span class="line">   date &#x3D; &quot;3&#x2F;27&#x2F;2003&quot;</span><br><span class="line">)</span><br><span class="line">class MyClass() &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(value &#x3D; &quot;unchecked&quot;)</span><br><span class="line">void myMethod() &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>当只有一个元素名字是 value 时，该名字可以省略，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">void myMethod() &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>若注解没有元素，则连圆括号都可以省略。</p>
<p>同一个声明可以用多个注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Author(name &#x3D; &quot;Jane Doe&quot;)</span><br><span class="line">@EBook</span><br><span class="line">class MyClass &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>若注解包含相同的类型，则被称为重复注解(repeating annotation)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Author(name &#x3D; &quot;Jane Doe&quot;)</span><br><span class="line">@Author(name &#x3D; &quot;John Smith&quot;)</span><br><span class="line">class MyClass &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>重复注解是 Java SE 8 里面支持的。</p>
<h2 id="注解使用的地方"><a href="#注解使用的地方" class="headerlink" title="注解使用的地方"></a>注解使用的地方</h2><p>注解可以应用到程序声明的类，字段，方法，和其他程序元素。当在一个声明中使用，按照惯例，每个注解经常会出现在它自己的行。</p>
<p>Java SE8 开始，注解也可以应用于类型使用（type use），称为类型注解（type annotation）。 这里有些例子：</p>
<ul>
<li>类实例创建表达式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new @Interned MyObject()</span><br></pre></td></tr></table></figure>

<ul>
<li>类型投射</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myString &#x3D; (@NonNull String) str;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现条款</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnmodifiableList&lt;T&gt; implements</span><br><span class="line">        @Readonly List&lt;@Readonly T&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抛出异常声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void monitorTemperature() throws</span><br><span class="line">        @Critical TemperatureException &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="声明一个注解类型"><a href="#声明一个注解类型" class="headerlink" title="声明一个注解类型"></a>声明一个注解类型</h2><p>许多注解取代了本来已经在代码中的注释。</p>
<p>假设传统的软件组在每个类的类体的开始，使用注释提供了重要的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation3List</span> <span class="keyword">extends</span> <span class="title">Generation2List</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Author: John Doe</span></span><br><span class="line">   <span class="comment">// Date: 3/17/2002</span></span><br><span class="line">   <span class="comment">// Current revision: 6</span></span><br><span class="line">   <span class="comment">// Last modified: 4/12/2004</span></span><br><span class="line">   <span class="comment">// By: Jane Doe</span></span><br><span class="line">   <span class="comment">// Reviewers: Alice, Bill, Cindy</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// class code goes here</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注解提供一样的元数据，首先要声明一个注解类型，语法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> ClassPreamble &#123;</span><br><span class="line">   <span class="function">String <span class="title">author</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">date</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">currentRevision</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">   <span class="function">String <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">default</span> &quot;N/A&quot;</span>;</span><br><span class="line">   <span class="function">String <span class="title">lastModifiedBy</span><span class="params">()</span> <span class="keyword">default</span> &quot;N/A&quot;</span>;</span><br><span class="line">   <span class="comment">// Note use of array</span></span><br><span class="line">   String[] reviewers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的声明，就像在 interface 声明前面添加一个<code>@</code>字符(<code>@</code>是AT,即 Annotation Type)。注解类型，其实是接口的一种特殊形式，后面会讲到。就目前而言，你不需要了解。</p>
<p>注解的声明的正文，包括注解元素的声明，看起来很像方法。注意，这里可以定义可选的默认值。</p>
<p>一旦注解定义好了，就可以在使用注解时，填充注解的值，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ClassPreamble (</span><br><span class="line">   author &#x3D; &quot;John Doe&quot;,</span><br><span class="line">   date &#x3D; &quot;3&#x2F;17&#x2F;2002&quot;,</span><br><span class="line">   currentRevision &#x3D; 6,</span><br><span class="line">   lastModified &#x3D; &quot;4&#x2F;12&#x2F;2004&quot;,</span><br><span class="line">   lastModifiedBy &#x3D; &quot;Jane Doe&quot;,</span><br><span class="line">   &#x2F;&#x2F; Note array notation</span><br><span class="line">   reviewers &#x3D; &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;&#125;</span><br><span class="line">)</span><br><span class="line">public class Generation3List extends Generation2List &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; class code goes here</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>要让<code>@ClassPreamble</code>的信息出现在 Javadoc 生成的文档，必须使用<code>@Documented</code>注解定义<code>@ClassPreamble</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import this to use @Documented</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@interface</span> ClassPreamble &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Annotation element definitions</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="预定义注解的类型"><a href="#预定义注解的类型" class="headerlink" title="预定义注解的类型"></a>预定义注解的类型</h2><p>有这么几种注解类型预定义在  Java SE API 了。一些注解类型是供 Java 编译器使用，一些是供其他注解使用。</p>
<h3 id="Java-语言使用的注解"><a href="#Java-语言使用的注解" class="headerlink" title="Java 语言使用的注解"></a>Java 语言使用的注解</h3><p>定义在 java.lang 中的是  <code>@Deprecated</code>, <code>@Override</code>, 和 <code>@SuppressWarnings</code></p>
<p><code>@Deprecated</code>注解指示，标识的元素是废弃的(deprecated)，不应该再使用。编译器会在任何使用到<code>@Deprecated</code>的类，方法，字段的程序时产生警告。当元素是废弃的，它也应该使用 Javadoc 的 <code>@deprecated</code> 标识文档化，如下面的例子。两个Javadoc 注释和注解中的“@”符号的使用不是巧合 - 它们是相关的概念上。另外，请注意Javadoc标记开始用小写字母“d”和注解开始以大写字母“D”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Javadoc comment follows</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @deprecated</span><br><span class="line">     * explanation of why it was deprecated</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Deprecated</span><br><span class="line">    static void deprecatedMethod() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Override</code>注解通知编译器，覆盖父类声明的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; mark method as a superclass method</span><br><span class="line">&#x2F;&#x2F; that has been overridden</span><br><span class="line">@Override </span><br><span class="line">int overriddenMethod() &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>虽然不要求在覆盖方法时，必须使用注解，但是它可以避免错误。如果一个方法标记为<code>@Override</code>，但是无法正确覆盖父类的任何方法，编译器会产生错误。</p>
<p><code>@SuppressWarnings</code>告诉编译器，抑制正常情况下会产生的特定的警告。下面的例子，一个废弃的方法被使用，编译器正常会产生警告，而这个情况下，这个注解导致警告会被抑制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use a deprecated method and tell </span></span><br><span class="line"><span class="comment">// compiler not to generate a warning</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useDeprecatedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// deprecation warning</span></span><br><span class="line">    <span class="comment">// - suppressed</span></span><br><span class="line">    objectOne.deprecatedMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个编译器的警告属于一个类别。Java 语言规范有两个类别：”deprecation” 和”unchecked”。”unchecked” 会在使用以前的写的泛型的遗留代码进行交互时，产生警告。抑制更多类别的警告，使用下面的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p><code>@SafeVarargs</code>注解，当应用于方法或构造，断言代码不对其可变参数（varargs）的参数进行潜在的不安全操作。当使用这个注释类型时，与可变参数相关未检查警告被抑制。</p>
<p><code>@FunctionalInterface</code>是在 Java SE 8 中引入，由 Java 语言规范定义的那样，表示该类型声明意在成为功能性的接口。</p>
<h3 id="注解应用于其他注解"><a href="#注解应用于其他注解" class="headerlink" title="注解应用于其他注解"></a>注解应用于其他注解</h3><p>注解应用于其他注解称为元注解（ meta-annotations）。java.lang.annotation 中定义了多种元注解。</p>
<p><code>@Retention</code> 注解指定了标记的注解如何存储：</p>
<ul>
<li>RetentionPolicy.SOURCE - 该标记注解只保留在源码级，在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。<code>@Override</code>、<code>@SuppressWarnings</code>都属于这类注解。</li>
<li>RetentionPolicy.CLASS - 该标记注释是由编译器在编译时保留， 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式。</li>
<li>RetentionPolicy.RUNTIME - 该标记注解由JVM保留，因此可以使用在运行时环境。因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</li>
</ul>
<p><code>@Documented</code>注释表明，只要指定哪些元素应该使用 Javadoc 工具。 （默认情况下，注解不包括在 Javadoc 中。）有关详细信息，请参阅的 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html">Javadoc 工具页面</a>。</p>
<p><code>@Target</code> 用于标记其他注解，限制什么样的 Java 元素的注解可以应用到。<code>@Target</code> 注解指定以下元素类型作为其值之一：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 可以应用于注释类型。</li>
<li>ElementType.CONSTRUCTOR 可以应用于构造体。</li>
<li>ElementType.FIELD 可以应用于一个字段或属性。</li>
<li>ElementType.LOCAL_VARIABLE 可以应用到局部变量。</li>
<li>ElementType.METHOD 可以应用于一方法级注释。</li>
<li>ElementType.PACKAGE 可以应用到一个包声明。</li>
<li>ElementType.PARAMETER 可以应用于方法的参数。</li>
<li>ElementType.TYPE 可以应用于类的任意元素。</li>
</ul>
<p><code>@Inherited</code> 指示注释类型可以从超类继承。（默认不是 true）。当用户查询注释类型,类没有这种类型注释，此时从这个类的父类中查询注释类型。这个注释只适用于类的声明。</p>
<p><code>@Repeatable</code>注解，在 Java SE 8 中引入的，表示该标记的注解可以多次应用到同一声明或类型使用。欲了解更多信息，请参阅重复注解。</p>
<h2 id="类型注解以及可拔插的类型系统"><a href="#类型注解以及可拔插的类型系统" class="headerlink" title="类型注解以及可拔插的类型系统"></a>类型注解以及可拔插的类型系统</h2><p>Java SE8 之前，注解只能用于声明，从 Java SE8 开始，注解也可以应用于类型使用（type use），称为类型注解（type annotation）。意味着，注解可以使用在任何使用的类型。</p>
<p>类型注解为 Java 程序提供了更强的类型检查分析。Java SE 8 版本不提供类​​型检查的框架，但它可以让你自己写（或下载）类型检查框架，该框架实现了与 Java 编译器一起使用的一个或多个可插拔模块。</p>
<p>例如，要确保在你的程序中一个特定变量从未被分配到 null ,从而避免引发NullPointerException 异常。您可以编写自定义插件来检查这一点。然后，您可以修改代码以注明这个特定变量，以表明它是永远不会分配给 null。变量声明可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@NonNull String str;</span><br></pre></td></tr></table></figure>

<p>当您编译代码，包括在命令行中的 NonNull 模块，如果它检测到潜在的问题，编译器输出警告，让您可以修改代码以避免错误。在更正代码后，消除所有警告，当程序运行时不会发生此​​特定错误。</p>
<p>您可以使用多个类型检查的模块，每个模块检查不同类型的错误。通过这种方式，你可以建立在 Java 类型系统之上，随时随地添加您想要的特定检查。</p>
<p>通过明智地使用类型注解和可插拔的类型检查器，你写的代码，将更强大，更不易出错。</p>
<p>在很多情况下，你不必写自己的类型检查模块。第三方组织已经在做这个工作了。例如，华盛顿大学(the University of Washington)创建的  Checker Framework 。该框架包括一个 NonNull 模块，以及一个正则表达式模块和互斥锁模块。欲了解更多信息，请参见 <a href="http://types.cs.washington.edu/checker-framework/">Checker Framework</a>。</p>
<h2 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h2><p>若注解包含相同的类型，则被称为重复注解(repeating annotation)，这个是 Java SE 8 之后所支持的。</p>
<p>比如，你正在编写的代码使用计时器服务，使您能够在特定的时间或在某个计划，类似于 UNIX cron 服务运行的方法。现在，你要设置一个计时器，在下午 11:00 运行的方法，doPeriodicCleanup，在每月和每周五的最后一天要设置定时运行，创建一个<code>@Schedule</code>注释，并两次将其应用到了 doPeriodicCleanup 方法。在第一次使用指定月的最后一天和第二指定星期五在下午11点，使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Schedule(dayOfMonth&#x3D;&quot;last&quot;)</span><br><span class="line">@Schedule(dayOfWeek&#x3D;&quot;Fri&quot;, hour&#x3D;&quot;23&quot;)</span><br><span class="line">public void doPeriodicCleanup() &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例是将注解应用在方法上。你可以在任何使用标准的注解地方使用重复注解。例如，你有一个类来处理未授权的访问异常。有一个<code>@Alert</code>注解的类标注为管理人员和另一个用于管理员：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Alert(role&#x3D;&quot;Manager&quot;)</span><br><span class="line">@Alert(role&#x3D;&quot;Administrator&quot;)</span><br><span class="line">public class UnauthorizedAccessException extends SecurityException &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>由于兼容性的原因，重复的注释被存储在一个由 Java 编译器自动产生的容器注解（container annotation）里。为了使编译器要做到这一点，你的代码里两个声明都需要。</p>
<h3 id="第一步：声明一个重复注解"><a href="#第一步：声明一个重复注解" class="headerlink" title="第一步：声明一个重复注解"></a>第一步：声明一个重复注解</h3><p>重复注解用 @Repeatable 元注解标记。下面例子定义一个自定义的 @Schedule 重复注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.Repeatable;</span><br><span class="line"></span><br><span class="line">@Repeatable(Schedules.class)</span><br><span class="line">public @interface Schedule &#123;</span><br><span class="line">  String dayOfMonth() default &quot;first&quot;;</span><br><span class="line">  String dayOfWeek() default &quot;Mon&quot;;</span><br><span class="line">  int hour() default 12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Repeatable</code>元注解的值是由 Java 编译器生成存储重复注解的容器注解的类型。在本例中，容器注解的类型是 Schedules，所以重复注解 <code>@Schedule</code> 被存储在<code>@Schedules</code> 注解中。</p>
<p>应用相同注解到声明但没有首先声明它是可重复的，则在编译时会出错。</p>
<h3 id="步骤2：声明容器注解类型"><a href="#步骤2：声明容器注解类型" class="headerlink" title="步骤2：声明容器注解类型"></a>步骤2：声明容器注解类型</h3><p>容器注解类型必须有数组类型的元素 value,而数组类型的组件类型必须是重复注解类型，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public @interface Schedules &#123;</span><br><span class="line">    Schedule[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检索注解"><a href="#检索注解" class="headerlink" title="检索注解"></a>检索注解</h3><p>反射 API 有几种方法可用于检索注解。返回单个注解的方法的行为，如<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html#getAnnotationByType-java.lang.Class-">AnnotatedElement.getAnnotationByType(Class<T>)</a>，如果所请求的类型的注解类型只存在一个则仅返回一个注解，则该行为是没有改变的。如果有多个请求类型的注解类型存在，则可以通过先得到他们的容器注解从而获取它们。这种方式下，传统代码继续工作。其他方法是在 Java SE 8 中，通过容器注释扫描到一次返回多个注解，如 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html#getAnnotations-java.lang.Class-">AnnotatedElement.getAnnotations(Class<T>)</a>。见<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html">AnnotatedElement</a> 类的规范，查看所有的可用方法的信息。</p>
<h3 id="设计考虑"><a href="#设计考虑" class="headerlink" title="设计考虑"></a>设计考虑</h3><p>当设计一个注解类型，你必须考虑到该类型的注解的基数(cardinality)。现在可以使用一个注释零次，一次，或者，如果注解的类型被标以<code>@Repeatable</code>，则不止一次。另外，也可以通过使用<code>@Target</code>元注解来限制注解类型在哪里使用。例如，您可以创建一个只能在方法和字段使用可重复的注解类型。精心设计的注解类型是非常重要的，要确保使用注解的程序员感觉越灵活和强大越好。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="如何定义注解"><a href="#如何定义注解" class="headerlink" title="如何定义注解"></a>如何定义注解</h3><p>我们自定义了一个注解 MyAnnotation，用来标识我们是什么公司:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">	String company() default &quot;waylau.com&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解只有一个方法声明 company()，默认值是字符串“waylau.com”。</p>
<h3 id="如何使用注解"><a href="#如何使用注解" class="headerlink" title="如何使用注解"></a>如何使用注解</h3><p>下面演示下如何用这个注解。</p>
<p>我们在测试类 AnnotationTest 的方法上加上了我们的注解，并设了值“<a href="http://www.waylau.com”：">www.waylau.com”：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">	@MyAnnotation(company&#x3D;&quot;https:&#x2F;&#x2F;waylau.com&quot;)</span><br><span class="line">    public void execute()&#123;</span><br><span class="line">        System.out.println(&quot;do something~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如果获取注解的信息"><a href="#如果获取注解的信息" class="headerlink" title="如果获取注解的信息"></a>如果获取注解的信息</h3><p>通过反射机制，我们可以获取到注解的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AnnotationTest test &#x3D; new AnnotationTest();</span><br><span class="line"></span><br><span class="line">test.execute();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取 AnnotationTest 的Class实例</span><br><span class="line">Class&lt;AnnotationTest&gt; c &#x3D; AnnotationTest.class;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取需要处理的方法Method实例</span><br><span class="line">Method method &#x3D; c.getMethod(&quot;execute&quot;, new Class[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断该方法是否包含 MyAnnotation 注解</span><br><span class="line">if(method.isAnnotationPresent(MyAnnotation.class))&#123;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F; 获取该方法的 MyAnnotation 注解实例</span><br><span class="line">    MyAnnotation myAnnotation &#x3D; method.getAnnotation(MyAnnotation.class);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 执行该方法</span><br><span class="line">    method.invoke(test, new Object[]&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取 myAnnotation 的属性值</span><br><span class="line">    String company &#x3D; myAnnotation.company();</span><br><span class="line">    System.out.println(company);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取方法上的所有注解</span><br><span class="line">Annotation[] annotations &#x3D; method.getAnnotations();</span><br><span class="line">	for(Annotation annotation : annotations)&#123;</span><br><span class="line">	    System.out.println(annotation);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行，正常情况下能看到如下打印信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>类和对象</title>
    <url>/2020/09/30/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="枚举类型（Enum-Type）"><a href="#枚举类型（Enum-Type）" class="headerlink" title="枚举类型（Enum Type）"></a>枚举类型（Enum Type）</h2><p>枚举类型是一种特殊的数据类型，使一个变量是一组预定义的常量。变量必须等于已预先定义的值之一。常见的例子包括罗盘方向（ NORTH, SOUTH, EAST 和 WEST）和星期几。</p>
<a id="more"></a>

<p>使用关键字 enum ，下面是一个星期几的枚举列子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Day &#123;</span><br><span class="line">    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用枚举类型，需要一组固定的常数。这包括自然枚举类型，如在我们的太阳系的行星，菜单上的选项，命令行标志，等等。</p>
<p>下面是一些代码，展示如何使用上面定义的 Day 枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Day day;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumTest</span><span class="params">(Day day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tellItLikeItIs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">            <span class="keyword">case</span> MONDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;Mondays are bad.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">case</span> FRIDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;Fridays are better.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                         </span><br><span class="line">            <span class="keyword">case</span> SATURDAY: <span class="keyword">case</span> SUNDAY:</span><br><span class="line">                System.out.println(<span class="string">&quot;Weekends are best.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Midweek days are so-so.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumTest firstDay = <span class="keyword">new</span> EnumTest(Day.MONDAY);</span><br><span class="line">        firstDay.tellItLikeItIs();</span><br><span class="line">        EnumTest thirdDay = <span class="keyword">new</span> EnumTest(Day.WEDNESDAY);</span><br><span class="line">        thirdDay.tellItLikeItIs();</span><br><span class="line">        EnumTest fifthDay = <span class="keyword">new</span> EnumTest(Day.FRIDAY);</span><br><span class="line">        fifthDay.tellItLikeItIs();</span><br><span class="line">        EnumTest sixthDay = <span class="keyword">new</span> EnumTest(Day.SATURDAY);</span><br><span class="line">        sixthDay.tellItLikeItIs();</span><br><span class="line">        EnumTest seventhDay = <span class="keyword">new</span> EnumTest(Day.SUNDAY);</span><br><span class="line">        seventhDay.tellItLikeItIs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mondays are bad.</span><br><span class="line">Midweek days are so-so.</span><br><span class="line">Fridays are better.</span><br><span class="line">Weekends are best.</span><br><span class="line">Weekends are best.</span><br></pre></td></tr></table></figure>

<p>下面是一个 Planet 示例，展示了 枚举值的 for-each 遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">    MERCURY (<span class="number">3.303e+23</span>, <span class="number">2.4397e6</span>),</span><br><span class="line">    VENUS   (<span class="number">4.869e+24</span>, <span class="number">6.0518e6</span>),</span><br><span class="line">    EARTH   (<span class="number">5.976e+24</span>, <span class="number">6.37814e6</span>),</span><br><span class="line">    MARS    (<span class="number">6.421e+23</span>, <span class="number">3.3972e6</span>),</span><br><span class="line">    JUPITER (<span class="number">1.9e+27</span>,   <span class="number">7.1492e7</span>),</span><br><span class="line">    SATURN  (<span class="number">5.688e+26</span>, <span class="number">6.0268e7</span>),</span><br><span class="line">    URANUS  (<span class="number">8.686e+25</span>, <span class="number">2.5559e7</span>),</span><br><span class="line">    NEPTUNE (<span class="number">1.024e+26</span>, <span class="number">2.4746e7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> mass;   <span class="comment">// in kilograms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> radius; <span class="comment">// in meters</span></span><br><span class="line">    Planet(<span class="keyword">double</span> mass, <span class="keyword">double</span> radius) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mass = mass;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">mass</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mass; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">radius</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// universal gravitational constant  (m3 kg-1 s-2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> G = <span class="number">6.67300E-11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">surfaceGravity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">surfaceWeight</span><span class="params">(<span class="keyword">double</span> otherMass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> otherMass * surfaceGravity();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Usage: java Planet &lt;earth_weight&gt;&quot;</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> earthWeight = Double.parseDouble(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">double</span> mass = earthWeight/EARTH.surfaceGravity();</span><br><span class="line">        <span class="keyword">for</span> (Planet p : Planet.values())</span><br><span class="line">           System.out.printf(<span class="string">&quot;Your weight on %s is %f%n&quot;</span>,</span><br><span class="line">                             p, p.surfaceWeight(mass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行，输入参数为 175 时，<br>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java Planet 175</span><br><span class="line">Your weight on MERCURY is 66.107583</span><br><span class="line">Your weight on VENUS is 158.374842</span><br><span class="line">Your weight on EARTH is 175.000000</span><br><span class="line">Your weight on MARS is 66.279007</span><br><span class="line">Your weight on JUPITER is 442.847567</span><br><span class="line">Your weight on SATURN is 186.552719</span><br><span class="line">Your weight on URANUS is 158.397260</span><br><span class="line">Your weight on NEPTUNE is 199.207413</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>通过方法声明异常抛出</title>
    <url>/2020/09/30/%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA/</url>
    <content><![CDATA[<h1 id="通过方法声明异常抛出"><a href="#通过方法声明异常抛出" class="headerlink" title="通过方法声明异常抛出"></a>通过方法声明异常抛出</h1><p>上一节展示了如何为ListOfNumbers类中的writeList方法编写异常处理程序。 有时，它适合代码捕获可能发生在其中的异常。<a id="more"></a> 但在其他情况下，最好让一个方法进一步推给上层来调用堆栈处理异常。<br>例如，如果您将ListOfNumbers类提供为类包的一部分，则可能无法预期包的所有用户的需求。 在这种情况下，最好不要捕获异常，并允许一个方法进一步推给上层来调用堆栈来处理它。</p>
<p>如果writeList方法没有捕获其中可能发生的已检查异常，则writeList方法必须指定它可以抛出这些异常。 让我们修改原始的writeList方法来指定它可以抛出的异常，而不是捕捉它们。 请注意，下面是不能编译的writeList方法的原始版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void writeList() &#123;</span><br><span class="line">    PrintWriter out &#x3D; new PrintWriter(new FileWriter(&quot;OutFile.txt&quot;));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; SIZE; i++) &#123;</span><br><span class="line">        out.println(&quot;Value at: &quot; + i + &quot; &#x3D; &quot; + list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>要指定writeList可以抛出两个异常，请为writeList方法的方法声明添加一个throws子句。 throws子句包含throws关键字，后面是由该方法抛出的所有异常的逗号分隔列表。 该子句在方法名和参数列表之后，在定义方法范围的大括号之前。这里是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void writeList() throws IOException, IndexOutOfBoundsException &#123;</span><br></pre></td></tr></table></figure>

<p>记住 IndexOutOfBoundsException是未检查异常（unchecked exception），包括它在throws子句中不是强制性的。 你可以写成下面这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void writeList() throws IOException &#123;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>网络基础</title>
    <url>/2020/09/30/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p>在互联网上之间的通信交流，一般是基于 TCP  (Transmission Control Protocol，传输控制协议) 或者 UDP (User Datagram Protocol，用户数据报协议) ，如下图：</p>
<a id="more"></a>

<p><img src="../images/net/1netw.gif"></p>
<p>编写 Java 应用，我们只需关注于应用层 （application layer），而不用关心 TCP 和 UDP 所在的传输层是如何实现的。java.net 包含了你编程所需的类，这些类是与操作系统无关的。比如 URL, URLConnection, Socket, 和 ServerSocket 类是使用 TCP 连接网络的， DatagramPacket, DatagramSocket, 和 MulticastSocket 类是用于  UDP  的。</p>
<p>Java 支持的协议只有  TCP 和 UDP ，以及在建立在  TCP 和 UDP 之上其他应用层协议。所有其他传输层、网际层和更底层的协议，如 ICMP、IGMP、ARP、RARP、RSVP 和其他协议 在 Java 中只能链接到原生代码来实现。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP (Transmission Control Protocol) 是面向连接的、提供端到端可靠的数据流(flow of data)。TCP 提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。 </p>
<p>“面向连接”就是在正式通信前必须要与对方建立起连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP 是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过三次“握手”才能建立起来，简单的讲就是：</p>
<ol>
<li>主机 A 向主机 B 发出连接请求数据包：“我想给你发数据，可以吗？”；</li>
<li>主机 B 向主机 A 发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你来吧”；</li>
<li>主机 A 再发出一个数据包确认主机 B 的要求同步：“好的，我来也，你接着吧！”</li>
</ol>
<p>三次“握手”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机 A 才向主机 B 正式发送数据。</p>
<p>可以详见<a href="http://www.waylau.com/tcp-connect-and-close/">《TCP 协议的三次握手、四次分手》</a></p>
<h3 id="如何保证数据的可靠"><a href="#如何保证数据的可靠" class="headerlink" title="如何保证数据的可靠"></a>如何保证数据的可靠</h3><p>TCP 通过下列方式来提供可靠性：</p>
<ul>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。这和 UDP 完全不同，应用程序产生的数据报长度将保持不变。由 TCP 传递给 IP 的信息单位称为报文段或段（segment）。</li>
<li>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。（可自行了解 TCP 协议中自适应的超时及重传策略）。</li>
<li>当  TCP 收到发自  TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</li>
<li>TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，  TCP 将丢弃这个报文段和不确认收到此报文段（希望发送端超时并重发）。</li>
<li>既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此  TCP 报文段的到达也可能会失序。如果必要，  TCP 将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</li>
<li>既然 IP 数据报会发生重复，  TCP 的接收端必须丢弃重复的数据。</li>
<li>TCP 还能提供流量控制。TCP 连接的每一方都有固定大小的缓冲空间。 TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP (User Datagram Protocol) 不是面向连接的，主机发送独立的数据报（datagram）给其他主机，不保证数据到达。由于 UDP 在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 </p>
<p>而无连接是一开始就发送信息（严格说来，这是没有开始、结束的），只是一次性的传递，是先不需要接受方的响应，因而在一定程度上也无法保证信息传递的可靠性了，就像写信一样，我们只是将信寄出去，却不能保证收信人一定可以收到。</p>
<h3 id="TCP-和-UDP-如何抉择"><a href="#TCP-和-UDP-如何抉择" class="headerlink" title="TCP 和 UDP 如何抉择"></a>TCP 和 UDP 如何抉择</h3><p>TCP 是面向连接的，有比较高的可靠性， 一些要求比较高的服务一般使用这个协议，如FTP、Telnet、SMTP、HTTP、POP3 等，而 UDP 是面向无连接的，使用这个协议的常见服务有 DNS、SNMP、QQ 等。对于 QQ 必须另外说明一下，QQ2003 以前是只使用UDP协议的，其服务器使用8000端口，侦听是否有信息传来，客户端使用 4000 端口，向外发送信息（这也就不难理解在一般的显IP的QQ版本中显示好友的IP地址信息中端口常为4000或其后续端口的原因了），即QQ程序既接受服务又提供服务，在以后的 QQ 版本中也支持使用 TCP 协议了。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>一般来说，一台计算机具有单个物理连接到网络。数据通过这个连接去往特定的计算机。然而，该数据可以被用于在计算机上运行的不同应用。那么，计算机知道哪个应用程序转发数据？通过使用端口。</p>
<p>在互联网上传输的数据是通过计算机的标识和端口来定位的。计算机的标识是 32-bit  的 IP 地址。端口由一个 16-bit 的数字。</p>
<p>在诸如面向连接的通信如 TCP，服务器应用将套接字绑定到一个特定端口号。这是向系统注册服务用来接受该端口的数据。然后，客户端可以在与服务器在服务器端口会合，如下图所示：</p>
<p><img src="../images/net/2tcp.gif"></p>
<p>TCP 和 UDP 协议使用的端口来将接收到的数据映射到一个计算机上运行的进程。</p>
<p>在基于数据报的通信，如 UDP，数据报包中包含它的目的地的端口号，然后 UDP 将数据包路由到相应的应用程序，如本图所示的端口号：</p>
<p><img src="../images/net/3tcpudp.gif"></p>
<p>端口号取值范围是从 0 到 65535 （16-bit 长度），其中范围从 0 到 1023 是受限的，它们是被知名的服务所保留使用，例如 HTTP （端口是 80）和 FTP （端口是20、21）等系统服务。这些端口被称为众所周知的端口（well-known ports）。您的应用程序不应该试图绑定到他们。你可以访问 <a href="http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a> 来查询各种常用的已经分配的端口号列表。</p>
]]></content>
  </entry>
  <entry>
    <title>IO模型的演进</title>
    <url>/2020/09/30/IO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E8%BF%9B/</url>
    <content><![CDATA[<h1 id="I-O-模型的演进"><a href="#I-O-模型的演进" class="headerlink" title="I/O 模型的演进"></a>I/O 模型的演进</h1><p>什么是同步？什么是异步？阻塞和非阻塞又有什么区别？本文先从 Unix 的 I/O 模型讲起，介绍了5种常见的 I/O 模型。而后再引出 Java 的 I/O 模型的演进过程，并用实例说明如何选择合适的 Java I/O<br>模型来提高系统的并发量和可用性。</p>
<a id="more"></a>

<p>由于，Java 的 I/O 依赖于操作系统的实现，所以先了解 Unix 的 I/O 模型有助于理解 Java 的 I/O。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>描述的是用户线程与内核的交互方式：</p>
<ul>
<li><strong>同步</strong>是指用户线程发起 I/O  请求后需要等待或者轮询内核 I/O 操作完成后才能继续执行；</li>
<li><strong>异步</strong>是指用户线程发起 I/O 请求后仍继续执行，当内核 I/O 操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</li>
</ul>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>描述的是用户线程调用内核 I/O 操作的方式：</p>
<ul>
<li><strong>阻塞</strong>是指 I/O 操作需要彻底完成后才返回到用户空间；</li>
<li><strong>非阻塞</strong>是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成。</li>
</ul>
<p>一个 I/O 操作其实分成了两个步骤：发起 I/O 请求和实际的 I/O 操作。<br>阻塞 I/O 和非阻塞 I/O 的区别在于第一步，发起 I/O 请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞 I/O ，如果不阻塞，那么就是非阻塞 I/O 。<br>同步 I/O 和异步 I/O 的区别就在于第二个步骤是否阻塞，如果实际的 I/O 读写阻塞请求进程，那么就是同步 I/O 。 </p>
<h3 id="Unix-I-O-模型"><a href="#Unix-I-O-模型" class="headerlink" title="Unix I/O 模型"></a>Unix I/O 模型</h3><p>Unix 下共有五种 I/O 模型： </p>
<ol>
<li>阻塞 I/O </li>
<li>非阻塞 I/O </li>
<li>I/O 复用（select 和 poll） </li>
<li>信号驱动 I/O（SIGIO） </li>
<li>异步 I/O（Posix.1 的 aio_ 系列函数）</li>
</ol>
<p>注：若读者想深入了解 Unix 的网络知识，推荐阅读《Unix Network Programming》，文本只简单介绍下这五种模型，文中的图例也引用自该书的图例。</p>
<h4 id="阻塞-I-O"><a href="#阻塞-I-O" class="headerlink" title="阻塞 I/O"></a>阻塞 I/O</h4><p>请求无法立即完成则保持阻塞。</p>
<ul>
<li>阶段1：等待数据就绪。网络 I/O 的情况就是等待远端数据陆续抵达；磁盘I/O的情况就是等待磁盘数据从磁盘上读取到内核态内存中。</li>
<li>阶段2：数据拷贝。出于系统安全,用户态的程序没有权限直接读取内核态内存,因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。</li>
</ul>
<p>![](../images/net/1-7 bio.png)</p>
<h4 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h4><ul>
<li>socket 设置为 NONBLOCK（非阻塞）就是告诉内核，当所请求的 I/O 操作无法完成时，不要将进程睡眠，而是返回一个错误码(EWOULDBLOCK) ，这样请求就不会阻塞</li>
<li>I/O 操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。整个 I/O 请求的过程中，虽然用户线程每次发起 I/O 请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的 CPU 的资源</li>
<li>数据准备好了，从内核拷贝到用户空间。</li>
</ul>
<p>![](../images/net/1-8 nio.png)</p>
<p>一般很少直接使用这种模型，而是在其他 I/O 模型中使用非阻塞 I/O 这一特性。这种方式对单个 I/O 请求意义不大,但给 I/O 多路复用铺平了道路.</p>
<h3 id="I-O-复用（异步阻塞-I-O）"><a href="#I-O-复用（异步阻塞-I-O）" class="headerlink" title="I/O 复用（异步阻塞 I/O）"></a>I/O 复用（异步阻塞 I/O）</h3><p>I/O 复用会用到 select 或者 poll 函数，这两个函数也会使进程阻塞，但是和阻塞 I/O 所不同的的，这两个函数可以同时阻塞多个 I/O 操作。而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。 </p>
<p>![](../images/net/1-9 io-multiplexing.png)</p>
<p>从流程上来看，使用 select 函数进行 I/O 请求和同步阻塞模型没有太大的区别，甚至还多了添加监视 socket，以及调用 select 函数的额外操作，效率更差。但是，使用 select 以后最大的优势是用户可以在一个线程内同时处理多个 socket 的 I/O 请求。用户可以注册多个 socket，然后不断地调用 select 读取被激活的 socket，即可达到在同一个线程内同时处理多个 I/O 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
<p>I/O 多路复用模型使用了 Reactor 设计模式实现了这一机制。</p>
<p>注：有关“Reactor 设计模式”请可参阅 <a href="https://en.wikipedia.org/wiki/Reactor_pattern">https://en.wikipedia.org/wiki/Reactor_pattern</a>。</p>
<p>调用 select / poll 该方法由一个用户态线程负责轮询多个 socket,直到某个阶段1的数据就绪,再通知实际的用户线程执行阶段2的拷贝。<br>通过一个专职的用户态线程执行非阻塞 I/O 轮询,模拟实现了阶段1的异步化。</p>
<h3 id="信号驱动-I-O（SIGIO）"><a href="#信号驱动-I-O（SIGIO）" class="headerlink" title="信号驱动 I/O（SIGIO）"></a>信号驱动 I/O（SIGIO）</h3><p>首先我们允许 socket 进行信号驱动 I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。</p>
<p>![](../images/net/1-10 signal-driven-io.png)</p>
<h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h3><p>调用 aio_read 函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<p>![](../images/net/1-11 aio.png)</p>
<p>异步 I/O 模型使用了 Proactor 设计模式实现了这一机制。</p>
<p>注：有关“Proactor 设计模式”可以参阅 <a href="https://en.wikipedia.org/wiki/Proactor_pattern">https://en.wikipedia.org/wiki/Proactor_pattern</a>。</p>
<p>告知内核,当整个过程(包括阶段1和阶段2)全部完成时,通知应用程序来读数据.</p>
<h2 id="几种-I-O-模型的比较"><a href="#几种-I-O-模型的比较" class="headerlink" title="几种 I/O 模型的比较"></a>几种 I/O 模型的比较</h2><p>前四种模型的区别是阶段1不相同，阶段2基本相同，都是将数据从内核拷贝到调用者的缓冲区。而异步 I/O 的两个阶段都不同于前四个模型。</p>
<p>同步 I/O 操作引起请求进程阻塞，直到 I/O 操作完成。异步 I/O 操作不引起请求进程阻塞。</p>
<p>![](../images/net/1-12 Comparison of the five IO models.png)</p>
<h2 id="常见-Java-I-O-模型"><a href="#常见-Java-I-O-模型" class="headerlink" title="常见 Java I/O 模型"></a>常见 Java I/O 模型</h2><p>在了解了 UNIX 的 I/O 模型之后，其实 Java 的 I/O 模型也是类似。</p>
<h2 id="“阻塞I-O”模式"><a href="#“阻塞I-O”模式" class="headerlink" title="“阻塞I/O”模式"></a>“阻塞I/O”模式</h2><p>在上一节 Socket 章节中的 EchoServer 就是一个简单的阻塞 I/O 例子，服务器启动后，等待客户端连接。在客户端连接服务器后，服务器就阻塞读写取数据流。</p>
<p>EchoServer 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">			port = DEFAULT_PORT;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            ServerSocket serverSocket =</span><br><span class="line">                <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            Socket clientSocket = serverSocket.accept();     </span><br><span class="line">            PrintWriter out =</span><br><span class="line">                <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);                   </span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">        ) &#123;</span><br><span class="line">            String inputLine;</span><br><span class="line">            <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.println(inputLine);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception caught when trying to listen on port &quot;</span></span><br><span class="line">                + port + <span class="string">&quot; or listening for a connection&quot;</span>);</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进为“阻塞I-O-多线程”模式"><a href="#改进为“阻塞I-O-多线程”模式" class="headerlink" title="改进为“阻塞I/O+多线程”模式"></a>改进为“阻塞I/O+多线程”模式</h2><p>使用多线程来支持多个客户端来访问服务器。</p>
<p>主线程 MultiThreadEchoServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadEchoServer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">			port = DEFAULT_PORT;</span><br><span class="line">		&#125;</span><br><span class="line">		Socket clientSocket = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);) &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				clientSocket = serverSocket.accept();</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// MultiThread</span></span><br><span class="line">				<span class="keyword">new</span> Thread(<span class="keyword">new</span> EchoServerHandler(clientSocket)).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(</span><br><span class="line">					<span class="string">&quot;Exception caught when trying to listen on port &quot;</span> + port + <span class="string">&quot; or listening for a connection&quot;</span>);</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理器类 EchoServerHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket clientSocket;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EchoServerHandler</span><span class="params">(Socket clientSocket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.clientSocket = clientSocket;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">				BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));) &#123;</span><br><span class="line"></span><br><span class="line">			String inputLine;</span><br><span class="line">			<span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				out.println(inputLine);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在问题</strong>：每次接收到新的连接都要新建一个线程，处理完成后销毁线程，代价大。当有大量地短连接出现时，性能比较低。</p>
<h2 id="改进为“阻塞I-O-线程池”模式"><a href="#改进为“阻塞I-O-线程池”模式" class="headerlink" title="改进为“阻塞I/O+线程池”模式"></a>改进为“阻塞I/O+线程池”模式</h2><p>针对上面多线程的模型中，出现的线程重复创建、销毁带来的开销，可以采用线程池来优化。每次接收到新连接后从池中取一个空闲线程进行处理，处理完成后再放回池中，重用线程避免了频率地创建和销毁线程带来的开销。</p>
<p>主线程 ThreadPoolEchoServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolEchoServer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">			port = DEFAULT_PORT;</span><br><span class="line">		&#125;</span><br><span class="line">		ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		Socket clientSocket = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);) &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				clientSocket = serverSocket.accept();</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Thread Pool</span></span><br><span class="line">				threadPool.submit(<span class="keyword">new</span> Thread(<span class="keyword">new</span> EchoServerHandler(clientSocket)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(</span><br><span class="line">					<span class="string">&quot;Exception caught when trying to listen on port &quot;</span> + port + <span class="string">&quot; or listening for a connection&quot;</span>);</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在问题</strong>：在大量短连接的场景中性能会有提升，因为不用每次都创建和销毁线程，而是重用连接池中的线程。但在大量长连接的场景中，因为线程被连接长期占用，不需要频繁地创建和销毁线程，因而没有什么优势。</p>
<p>虽然这种方法可以适用于小到中度规模的客户端的并发数，如果连接数超过 100,000或更多，那么性能将很不理想。</p>
<h2 id="改进为“非阻塞I-O”模式"><a href="#改进为“非阻塞I-O”模式" class="headerlink" title="改进为“非阻塞I/O”模式"></a>改进为“非阻塞I/O”模式</h2><p>“阻塞I/O+线程池”网络模型虽然比”阻塞I/O+多线程”网络模型在性能方面有提升，但这两种模型都存在一个共同的问题：读和写操作都是同步阻塞的,面对大并发（持续大量连接同时请求）的场景，需要消耗大量的线程来维持连接。CPU 在大量的线程之间频繁切换，性能损耗很大。一旦单机的连接超过1万，甚至达到几万的时候，服务器的性能会急剧下降。</p>
<p>而 NIO 的 Selector 却很好地解决了这个问题，用主线程（一个线程或者是 CPU 个数的线程）保持住所有的连接，管理和读取客户端连接的数据，将读取的数据交给后面的线程池处理，线程池处理完业务逻辑后，将结果交给主线程发送响应给客户端，少量的线程就可以处理大量连接的请求。</p>
<p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
</ul>
<p>要使用 Selector，得向 Selector 注册 Channel，然后调用它的 select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
<p>主线程 NonBlokingEchoServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlokingEchoServer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">			port = DEFAULT_PORT;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Listening for connections on port &quot;</span> + port);</span><br><span class="line"></span><br><span class="line">		ServerSocketChannel serverChannel;</span><br><span class="line">		Selector selector;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			serverChannel = ServerSocketChannel.open();</span><br><span class="line">			InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">			serverChannel.bind(address);</span><br><span class="line">			serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">			selector = Selector.open();</span><br><span class="line">			serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				selector.select();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">				ex.printStackTrace();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">			Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">			<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">				SelectionKey key = iterator.next();</span><br><span class="line">				iterator.remove();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">						ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">						SocketChannel client = server.accept();</span><br><span class="line">						System.out.println(<span class="string">&quot;Accepted connection from &quot;</span> + client);</span><br><span class="line">						client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">						SelectionKey clientKey = client.register(selector,</span><br><span class="line">								SelectionKey.OP_WRITE | SelectionKey.OP_READ);</span><br><span class="line">						ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">						clientKey.attach(buffer);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">						SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">						ByteBuffer output = (ByteBuffer) key.attachment();</span><br><span class="line">						client.read(output);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">						SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">						ByteBuffer output = (ByteBuffer) key.attachment();</span><br><span class="line">						output.flip();</span><br><span class="line">						client.write(output);</span><br><span class="line">						</span><br><span class="line">						output.compact();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">					key.cancel();</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						key.channel().close();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (IOException cex) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进为“异步I-O”模式"><a href="#改进为“异步I-O”模式" class="headerlink" title="改进为“异步I/O”模式"></a>改进为“异步I/O”模式</h2><p>Java SE 7 版本之后，引入了异步 I/O （NIO.2） 的支持，为构建高性能的网络应用提供了一个利器。</p>
<p>主线程 AsyncEchoServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">			port = DEFAULT_PORT;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ExecutorService taskExecutor = Executors.newCachedThreadPool(Executors.defaultThreadFactory());</span><br><span class="line">		<span class="comment">// create asynchronous server socket channel bound to the default group</span></span><br><span class="line">		<span class="keyword">try</span> (AsynchronousServerSocketChannel asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (asynchronousServerSocketChannel.isOpen()) &#123;</span><br><span class="line">				<span class="comment">// set some options</span></span><br><span class="line">				asynchronousServerSocketChannel.setOption(StandardSocketOptions.SO_RCVBUF, <span class="number">4</span> * <span class="number">1024</span>);</span><br><span class="line">				asynchronousServerSocketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, <span class="keyword">true</span>);</span><br><span class="line">				<span class="comment">// bind the server socket channel to local address</span></span><br><span class="line">				asynchronousServerSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">				<span class="comment">// display a waiting message while ... waiting clients</span></span><br><span class="line">				System.out.println(<span class="string">&quot;Waiting for connections ...&quot;</span>);</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					Future&lt;AsynchronousSocketChannel&gt; asynchronousSocketChannelFuture = asynchronousServerSocketChannel</span><br><span class="line">							.accept();</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">final</span> AsynchronousSocketChannel asynchronousSocketChannel = asynchronousSocketChannelFuture</span><br><span class="line">								.get();</span><br><span class="line">						Callable&lt;String&gt; worker = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">								String host = asynchronousSocketChannel.getRemoteAddress().toString();</span><br><span class="line">								System.out.println(<span class="string">&quot;Incoming connection from: &quot;</span> + host);</span><br><span class="line">								<span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">								<span class="comment">// transmitting data</span></span><br><span class="line">								<span class="keyword">while</span> (asynchronousSocketChannel.read(buffer).get() != -<span class="number">1</span>) &#123;</span><br><span class="line">									buffer.flip();</span><br><span class="line">									asynchronousSocketChannel.write(buffer).get();</span><br><span class="line">									<span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">										buffer.compact();</span><br><span class="line">									&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">										buffer.clear();</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								asynchronousSocketChannel.close();</span><br><span class="line">								System.out.println(host + <span class="string">&quot; was successfully served!&quot;</span>);</span><br><span class="line">								<span class="keyword">return</span> host;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;;</span><br><span class="line">						taskExecutor.submit(worker);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException ex) &#123;</span><br><span class="line">						System.err.println(ex);</span><br><span class="line">						System.err.println(<span class="string">&quot;\n Server is shutting down ...&quot;</span>);</span><br><span class="line">						<span class="comment">// this will make the executor accept no new threads</span></span><br><span class="line">						<span class="comment">// and finish all existing threads in the queue</span></span><br><span class="line">						taskExecutor.shutdown();</span><br><span class="line">						<span class="comment">// wait until all threads are finished</span></span><br><span class="line">						<span class="keyword">while</span> (!taskExecutor.isTerminated()) &#123;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;The asynchronous server-socket channel cannot be opened!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			System.err.println(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本章例子的源码，可以在 <a href="https://github.com/waylau/essential-java">https://github.com/waylau/essential-java</a> 中 <code>com.waylau.essentialjava.net.echo</code> 包下找到。</p>
]]></content>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2020/09/30/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h1><p>泛型通过在编译时检测到更多的代码 bug 从而使你的代码更加稳定。</p>
<a id="more"></a>

<h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><p>概括地说，泛型支持类型（类和接口）在定义类，接口和方法时作为参数。就像在方法声明中使用的形式参数（formal parameters），类型参数提供了一种输入可以不同但代码可以重用的方式。所不同的是，形式参数的输入是值，类型参数输入的是类型参数。</p>
<p>使用泛型对比非泛型代码有很多好处：</p>
<ul>
<li>在编译时更强的类型检查。</li>
</ul>
<p>如果代码违反了类型安全，Java 编译器将针对泛型和问题错误采用强大的类型检查。修正编译时的错误比修正运行时的错误更加容易。</p>
<ul>
<li>消除了强制类型转换。</li>
</ul>
<p>没有泛型的代码片需要强制转化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List list &#x3D; new ArrayList();</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line">String s &#x3D; (String) list.get(0);</span><br></pre></td></tr></table></figure>

<p>当重新编写使用泛型，代码不需要强转：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;hello&quot;);</span><br><span class="line">String s &#x3D; list.get(0);   &#x2F;&#x2F; no cast</span><br></pre></td></tr></table></figure>

<ul>
<li>使编程人员能够实现通用算法。</li>
</ul>
<p>通过使用泛型，程序员可以实现工作在不同类型集合的通用算法，并且是可定制，类型安全，易于阅读。</p>
<h2 id="泛型类型（Generic-Type）"><a href="#泛型类型（Generic-Type）" class="headerlink" title="泛型类型（Generic Type）"></a>泛型类型（Generic Type）</h2><p>泛型类型是参数化类型的泛型类或接口。下面是一个 Box 类例子来说明这个概念。</p>
<h3 id="一个简单的-Box-类"><a href="#一个简单的-Box-类" class="headerlink" title="一个简单的 Box 类"></a>一个简单的 Box 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.object = object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于它的方法接受或返回一个 Object，你可以自由地传入任何你想要的类型，只要它不是原始的类型之一。在编译时，没有办法验证如何使用这个类。代码的一部分可以设置 Integer 并期望得到 Integer ，而代码的另一部分可能会由于错误地传递一个String ，而导致运行错误。</p>
<h3 id="一个泛型版本的-Box-类"><a href="#一个泛型版本的-Box-类" class="headerlink" title="一个泛型版本的 Box 类"></a>一个泛型版本的 Box 类</h3><p>泛型类定义语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class name&lt;T1, T2, ..., Tn&gt; &#123; &#x2F;* ... *&#x2F; &#125;</span><br></pre></td></tr></table></figure>

<p>类型参数部分用 <code>&lt;&gt;</code> 包裹，制定了类型参数或称为类型变量（type parameters or  type variables) T1, T2, …, 直到 Tn.</p>
<p>下面是代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要，所有的 Object 被 T 代替了。类型变量可以是非基本类型的的任意类型，任意的类、接口、数组或其他类型变量。</p>
<p>这个技术同样适用于泛型接口的创建。</p>
<h3 id="类型参数命名规范"><a href="#类型参数命名规范" class="headerlink" title="类型参数命名规范"></a>类型参数命名规范</h3><p>按照惯例，类型参数名称是单个大写字母，用来区别普通的类或接口名称。</p>
<p>常用的类型参数名称如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E - Element (由 Java 集合框架广泛使用)</span><br><span class="line">K - Key</span><br><span class="line">N - Number</span><br><span class="line">T - Type</span><br><span class="line">V - Value</span><br><span class="line">S,U,V 等. - 第二种、第三种、第四种类型</span><br></pre></td></tr></table></figure>

<h3 id="调用和实例化一个泛型"><a href="#调用和实例化一个泛型" class="headerlink" title="调用和实例化一个泛型"></a>调用和实例化一个泛型</h3><p>从代码中引用泛型 Box 类，则必须执行一个泛型调用(generic type invocation)，用具体的值，比如 Integer 取代 T ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox;</span><br></pre></td></tr></table></figure>

<p>泛型调用与普通的方法调用类似，所不同的是传递参数是类型参数（type argument ），本例就是传递 Integer 到 Box 类：</p>
<p><em>Type Parameter 和 Type Argument 区别</em></p>
<p><em>编码时，提供  type argument 的一个原因是为了创建 参数化类型。因此，<code>Foo&lt;T&gt;</code> 中的 T 是一个 type parameter， 而 <code>Foo&lt;String&gt;</code> 中的 String 是一个 type argument</em></p>
<p>与其他变量声明类似，代码实际上没有创建一个新的 Box 对象。它只是声明integerBox 在读到 <code>Box&lt;Integer&gt;</code> 时，保存一个“Integer 的 Box”的引用。</p>
<p>泛型的调用通常被称为一个参数化类型（parameterized type）。</p>
<p>实例化类，使用 new 关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox &#x3D; new Box&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="菱形（Diamond）"><a href="#菱形（Diamond）" class="headerlink" title="菱形（Diamond）"></a>菱形（Diamond）</h3><p>Java SE 7 开始泛型可以使用空的类型参数集<code>&lt;&gt;</code>，只要编译器能够确定，或推断，该类型参数所需的类型参数。这对尖括号<code>&lt;&gt;</code>，被非正式地称为“菱形（diamond）”。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox &#x3D; new Box&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="多类型参数"><a href="#多类型参数" class="headerlink" title="多类型参数"></a>多类型参数</h3><p>下面是一个泛型 Pair 接口和一个泛型 OrderedPair ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Pair&lt;K, V&gt; &#123;</span><br><span class="line">    public K getKey();</span><br><span class="line">    public V getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrderedPair&lt;K, V&gt; implements Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public OrderedPair(K key, V value) &#123;</span><br><span class="line">	this.key &#x3D; key;</span><br><span class="line">	this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K getKey()	&#123; return key; &#125;</span><br><span class="line">    public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个 OrderedPair 实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p1 &#x3D; new OrderedPair&lt;String, Integer&gt;(&quot;Even&quot;, 8);</span><br><span class="line">Pair&lt;String, String&gt;  p2 &#x3D; new OrderedPair&lt;String, String&gt;(&quot;hello&quot;, &quot;world&quot;);</span><br></pre></td></tr></table></figure>

<p>代码 <code>new OrderedPair&lt;String, Integer&gt;</code>，实例 K 作为一个 String 和 V 为 Integer。因此，OrderedPair 的构造函数的参数类型是 String 和 Integer。由于自动装箱（autoboxing），可以有效的传递一个 String 和 int 到这个类。</p>
<p>可以使用菱形（diamond）来简化代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OrderedPair&lt;String, Integer&gt; p1 &#x3D; new OrderedPair&lt;&gt;(&quot;Even&quot;, 8);</span><br><span class="line">OrderedPair&lt;String, String&gt;  p2 &#x3D; new OrderedPair&lt;&gt;(&quot;hello&quot;, &quot;world&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h3><p>您也可以用 参数化类型（例如，<code>List&lt;String&gt;</code>的）来替换类型参数（即 K 或 V ）。例如，使用<code>OrderedPair&lt;K，V&gt;</code>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p &#x3D; new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...));</span><br></pre></td></tr></table></figure>

<h3 id="原生类型（Raw-Types）"><a href="#原生类型（Raw-Types）" class="headerlink" title="原生类型（Raw Types）"></a>原生类型（Raw Types）</h3><p>原生类型是没有类型参数(type arguments)的泛型类和泛型接口，如泛型 Box 类;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要创建参数化类型的<code>Box&lt;T&gt;</code>，需要为形式类型参数T提供实际的类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>如果想省略实际的类型参数，则需要创建一个<code>Box&lt;T&gt;</code>的原生类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box rawBox = <span class="keyword">new</span> Box();</span><br></pre></td></tr></table></figure>

<p>因此，Box是泛型<code>Box&lt;T&gt;</code>的原生类型。但是，非泛型的类或接口类型不是原始类型。</p>
<p>JDK为了保证向后兼容，允许将参数化类型分配给其原始类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">Box rawBox = stringBox;               <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>但如果将原始类型与参数化类型进行管理，则会得到告警：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box rawBox = <span class="keyword">new</span> Box();           <span class="comment">// rawBox is a raw type of Box&lt;T&gt;</span></span><br><span class="line">Box&lt;Integer&gt; intBox = rawBox;     <span class="comment">// warning: unchecked conversion</span></span><br></pre></td></tr></table></figure>

<p>如果使用原始类型调用相应泛型类型中定义的泛型方法，也会收到警告：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">Box rawBox = stringBox;</span><br><span class="line">rawBox.set(<span class="number">8</span>);  <span class="comment">// warning: unchecked invocation to set(T)</span></span><br></pre></td></tr></table></figure>


<p>警告显示原始类型绕过泛型类型检查，将不安全代码的捕获推迟到运行时。因此，开发人员应该避免使用原始类型。</p>
<h2 id="泛型方法（Generic-Method）"><a href="#泛型方法（Generic-Method）" class="headerlink" title="泛型方法（Generic Method）"></a>泛型方法（Generic Method）</h2><p>泛型方法是引入其自己的类型参数的方法。这类似于声明泛型类型，但类型参数的范围仅限于声明它的方法。允许使用静态和非静态泛型方法，以及泛型类构造函数。</p>
<p>泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。</p>
<p>下面例子中，Util类包含一个泛型方法compare，用于比较两个Pair对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">               p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是方法的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">2</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> same = Util.&lt;Integer, String&gt;compare(p1, p2);</span><br></pre></td></tr></table></figure>

<p>其中，compare方法的类型通常可以省略，因为编译器将推断所需的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">2</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> same = Util.compare(p1, p2);</span><br></pre></td></tr></table></figure>


<h2 id="有界类型参数（Bounded-Type-Parameter）"><a href="#有界类型参数（Bounded-Type-Parameter）" class="headerlink" title="有界类型参数（Bounded Type Parameter）"></a>有界类型参数（Bounded Type Parameter）</h2><p>有时可能希望限制可在参数化类型中用作类型参数的类型。例如，对数字进行操作的方法可能只想接受Number或其子类的实例。这时，就需要用到有界类型参数。</p>
<p>要声明有界类型参数，先要列出类型参数的名称，然后是extends关键字，后面跟着它的上限，比如下面例子中的Number：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;          </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;U extends Number&gt; <span class="function"><span class="keyword">void</span> <span class="title">inspect</span><span class="params">(U u)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;T: &quot;</span> + t.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;U: &quot;</span> + u.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line">        integerBox.set(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">        integerBox.inspect(<span class="string">&quot;some text&quot;</span>); <span class="comment">// error: this is still String!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码将会编译失败，报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box.java:21: &lt;U&gt;inspect(U) in Box&lt;java.lang.Integer&gt; cannot</span><br><span class="line">  be applied to (java.lang.String)</span><br><span class="line">                        integerBox.inspect(&quot;10&quot;);</span><br><span class="line">                                  ^</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure>


<p>除了限制可用于实例化泛型类型的类型之外，有界类型参数还允许调用边界中定义的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaturalNumber</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NaturalNumber</span><span class="params">(T n)</span>  </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n.intValue() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面例子中，isEven方法通过n调用Integer类中定义的intValue方法。</p>
<h3 id="多个边界"><a href="#多个边界" class="headerlink" title="多个边界"></a>多个边界</h3><p>前面的示例说明了使用带有单个边界的类型参数，但是类型参数其实是可以有多个边界的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T extends B1 &amp; B2 &amp; B3&gt;</span><br></pre></td></tr></table></figure>

<p>具有多个边界的类型变量是绑定中列出的所有类型的子类型。如果其中一个边界是类，则必须首先指定它。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">B</span> &amp; <span class="title">C</span>&gt; </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果未首先指定绑定A，则会出现编译时错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">B</span> &amp; <span class="title">A</span> &amp; <span class="title">C</span>&gt; </span>&#123; <span class="comment">/* ... */</span> &#125;  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>


<p><strong>注</strong>：在有界类型参数中的extends，即可以表示“extends”（类中的继承）也可以表示“implements”（接口中的实现）。</p>
<h2 id="泛型的继承和子类型"><a href="#泛型的继承和子类型" class="headerlink" title="泛型的继承和子类型"></a>泛型的继承和子类型</h2><p>在Java中，只要类型兼容，就可以将一种类型的对象分配给另一种类型的对象。例如，可以将Integer分配给Object，因为Object是Integer的超类之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object someObject = <span class="keyword">new</span> Object();</span><br><span class="line">Integer someInteger = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">someObject = someInteger;   <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>在面向对象的术语中，这种关系被称为“is-a”。 由于Integer是一种Object，因此允许赋值。但是Integer同时也是一种Number，所以下面的代码也是有效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(Number n)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">someMethod(<span class="keyword">new</span> Integer(<span class="number">10</span>));   <span class="comment">// OK</span></span><br><span class="line">someMethod(<span class="keyword">new</span> Double(<span class="number">10.1</span>));   <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>在泛型中也是如此。 可以执行泛型类型调用，将Number作为其类型参数传递，如果参数与Number兼容，则允许任何后续的add调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Number&gt; box = <span class="keyword">new</span> Box&lt;Number&gt;();</span><br><span class="line">box.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));   <span class="comment">// OK</span></span><br><span class="line">box.add(<span class="keyword">new</span> Double(<span class="number">10.1</span>));  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>


<p>现在考虑下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boxTest</span><span class="params">(Box&lt;Number&gt; n)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>


<p>通过查看其签名，可以看到上述方法接受一个类型为<code>Box&lt;Number&gt;</code>的参数。也许你可能会想当然的认为这个方法也能接收<code>Box&lt;Integer&gt;</code>或<code>Box&lt;Double&gt;</code>吧？ 答案是否定的，因为<code>Box&lt;Integer&gt;</code>和<code>Box&lt;Double&gt;</code>并不是<code>Box&lt;Number&gt;</code>的子类型。在使用泛型编程时，这是一个常见的误解，虽然Integer和Double是Number的子类型。</p>
<p>下图展示了泛型和子类型的之间的关系：</p>
<p><img src="../images/generics/generics-subtypeRelationship.gif"></p>
<h3 id="泛型类及子类"><a href="#泛型类及子类" class="headerlink" title="泛型类及子类"></a>泛型类及子类</h3><p>可以通过扩展或实现泛型类或接口来对其进行子类型化。一个类或接口的类型参数与另一个类或参数的类型参数之间的关系由extends和implements子句确定。</p>
<p>以Collections类为例，<code>ArrayList&lt;E&gt;</code>实现了<code>List&lt;E&gt;</code>，而<code>List&lt;E&gt;</code>扩展了<code>Collection&lt;E&gt;</code>。所以<code>ArrayList&lt;String&gt;</code>是<code>List&lt;String&gt;</code>的子类型，同时它也是<code>Collection&lt;String&gt;</code>的子类型。只要不改变类型参数，就会在类型之间保留子类型关系。下图展示了这些类的层次关系：</p>
<p><img src="../images/generics/generics-sampleHierarchy.gif"></p>
<p>现在假设我们想要定义我们自己的列表接口PayloadList，它将泛型类型P的可选值与每个元素相关联。它的声明可能如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PayloadList</span>&lt;<span class="title">E</span>,<span class="title">P</span>&gt; <span class="keyword">extends</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setPayload</span><span class="params">(<span class="keyword">int</span> index, P val)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是PayloadList参数化的<code>List&lt;String&gt;</code>的子类型：</p>
<ul>
<li>PayloadList&lt;String,String&gt;</li>
<li>PayloadList&lt;String,Integer&gt;</li>
<li>PayloadList&lt;String,Exception&gt;</li>
</ul>
<p>这些类的关系图如下：</p>
<p><img src="../images/generics/generics-payloadListHierarchy.gif"></p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>通配符（?）通常用于表示未知类型。通配符可用于各种情况：</p>
<ul>
<li>作为参数，字段或局部变量的类型; </li>
<li>作为返回类型。 </li>
</ul>
<p>在泛型中，通配符不用于泛型方法调用，泛型类实例创建或超类型的类型参数。</p>
<h3 id="上限有界通配符"><a href="#上限有界通配符" class="headerlink" title="上限有界通配符"></a>上限有界通配符</h3><p>可以使用上限通配符来放宽对变量的限制。例如，要编写一个适用于<code>List&lt;Integer&gt;</code>、<code>List&lt;Double&gt;</code>和<code>List&lt;Number&gt;</code>的方法，可以通过使用上限有界通配符来实现这一点。比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sumOfList</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list)</span><br><span class="line">        s += n.doubleValue();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以指定类型为List<Integer>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sum = &quot;</span> + sumOfList(li));</span><br></pre></td></tr></table></figure>

<p>则输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum &#x3D; 6.0</span><br></pre></td></tr></table></figure>

<p>可以指定类型为List<Double>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Double&gt; ld = Arrays.asList(<span class="number">1.2</span>, <span class="number">2.3</span>, <span class="number">3.5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sum = &quot;</span> + sumOfList(ld));</span><br></pre></td></tr></table></figure>

<p>则输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum &#x3D; 7.0</span><br></pre></td></tr></table></figure>



<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符类型通常用于定义未知类型，比如<code>List&lt;?&gt;</code>。 </p>
<p>无界通配符通常有两种典型的用法：</p>
<h4 id="1-需要使用Object类中提供的功能实现的方法"><a href="#1-需要使用Object类中提供的功能实现的方法" class="headerlink" title="1. 需要使用Object类中提供的功能实现的方法"></a>1. 需要使用Object类中提供的功能实现的方法</h4><p>考虑以下方法printList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object elem : list)</span><br><span class="line">        System.out.println(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>printList只能打印一个Object实例列表，不能打印<code>List&lt;Integer&gt;</code>，<code>List&lt;String&gt;</code>，<code>List&lt;Double&gt;</code>等，因为它们不是<code>List&lt;Object&gt;</code>的子类型。</p>
<h4 id="2-当代码使用泛型类中不依赖于类型参数的方法"><a href="#2-当代码使用泛型类中不依赖于类型参数的方法" class="headerlink" title="2. 当代码使用泛型类中不依赖于类型参数的方法"></a>2. 当代码使用泛型类中不依赖于类型参数的方法</h4><p>例如，List.size或List.clear。实际上，经常使用<code>Class&lt;?&gt;</code>，因为<code>Class&lt;T&gt;</code>中的大多数方法都不依赖于T。比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object elem: list)</span><br><span class="line">        System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>List&lt;A&gt;</code>是<code>List&lt;?&gt;</code>的子类，因此可以打印出任何类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;String&gt;  ls = Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">printList(li);</span><br><span class="line">printList(ls);</span><br></pre></td></tr></table></figure>

<p>因此，要区分场景来选择使用<code>List&lt;Object&gt;</code>或是<code>List&lt;?&gt;</code>。如果想插入一个Object或者是任意Object的子类，就可以使用<code>List&lt;Object&gt;</code>。但只能在<code>List&lt;?&gt;</code>中插入null。</p>
<h3 id="下限有界通配符"><a href="#下限有界通配符" class="headerlink" title="下限有界通配符"></a>下限有界通配符</h3><p>下限有界通配符将未知类型限制为该类型的特定类型或超类型。使用下限有界通配符语法为<code>&lt;? super A&gt;</code>。</p>
<p>假设要编写一个将Integer对象放入列表的方法。为了最大限度地提高灵活性，希望该方法可以处理<code>List&lt;Integer&gt;</code>、<code>List&lt;Number&gt;</code>或者是<code>List&lt;Object&gt;</code>等可以保存Integer值的方法。</p>
<p>比如下面的例子，将数字1到10添加到列表的末尾：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumbers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通配符及其子类"><a href="#通配符及其子类" class="headerlink" title="通配符及其子类"></a>通配符及其子类</h3><p>可以使用通配符在泛型类或接口之间创建关系。</p>
<p>给定以下两个常规（非泛型）类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码是成立的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">A a = b;</span><br></pre></td></tr></table></figure>

<p>此示例显示常规类的继承遵循此子类型规则：如果B扩展A，则类B是类A的子类型。但此规则不适用于泛型类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;B&gt; lb = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;A&gt; la = lb;   <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>

<p>鉴于Integer是Number的子类型，<code>List&lt;Integer&gt;</code>和<code>List&lt;Number&gt;</code>之间的关系是什么？下图显示了<code>List&lt;Integer&gt;</code>和<code>List&lt;Number&gt;</code>的公共父级是未知类型<code>List&lt;?&gt;</code>。</p>
<p><img src="../images/generics/generics-listParent.gif"></p>
<p>尽管Integer是Number的子类型，但<code>List&lt;Integer&gt;</code>并不是<code>List&lt;Number&gt;</code>的子类型。</p>
<p>为了在这些类之间创建关系以便代码可以通过<code>List&lt;Integer&gt;</code>的元素访问Number的方法，需使用上限有界通配符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;? extends Number&gt;  numList = intList;  <span class="comment">// OK. List&lt;? extends Integer&gt; is a subtype of List&lt;? extends Number&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为Integer是Number的子类型，而numList是Number对象的列表，所以intList（Integer对象列表）和numList之间现在存在关系。下图显示了使用上限和下限有界通配符声明的多个List类之间的关系。</p>
<p><img src="../images/generics/generics-wildcardSubtyping.gif"></p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型被引入到Java语言中，以便在编译时提供更严格的类型检查并支持泛型编程。为了实现泛型，Java编译器将类型擦除应用于：</p>
<ul>
<li>如果类型参数是无界的，则用泛型或对象替换泛型类型中的所有类型参数。因此，生成的字节码仅包含普通的类\接口和方法。</li>
<li>如有必要，插入类型铸件以保持类型安全。</li>
<li>生成桥接方法以保留扩展泛型类型中的多态性。</li>
</ul>
<p>类型擦除能够确保不为参数化类型创建新类，因此，泛型不会产生运行时开销。</p>
<h3 id="擦除泛型类型"><a href="#擦除泛型类型" class="headerlink" title="擦除泛型类型"></a>擦除泛型类型</h3><p>在类型擦除过程中，Java编译器将擦除所有类型参数，并在类型参数有界时将其替换为第一个绑定，如果类型参数为无界，则替换为Object。</p>
<p>考虑以下表示单链表中节点的泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为类型参数T是无界的，所以Java编译器将其替换为Object：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以下示例中，泛型Node类使用有界类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Java编译器将有界类型参数T替换为第一个绑定类Comparable：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Comparable data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Comparable data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="擦除泛型方法"><a href="#擦除泛型方法" class="headerlink" title="擦除泛型方法"></a>擦除泛型方法</h3><p>Java编译器还会擦除泛型方法参数中的类型参数。请考虑以下泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(T[] anArray, T elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T e : anArray)</span><br><span class="line">        <span class="keyword">if</span> (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为T是无界的，Java编译器将会将它替换为Object：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(Object[] anArray, Object elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object e : anArray)</span><br><span class="line">        <span class="keyword">if</span> (e.equals(elem))</span><br><span class="line">            ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设定义了以下类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>可以使用泛型方法绘制不同的图形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Shape&gt; <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(T shape)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>Java编译器将会将T替换为Shape：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Shape shape)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用泛型的一些限制"><a href="#使用泛型的一些限制" class="headerlink" title="使用泛型的一些限制"></a>使用泛型的一些限制</h2><h3 id="无法使用基本类型实例化泛型"><a href="#无法使用基本类型实例化泛型" class="headerlink" title="无法使用基本类型实例化泛型"></a>无法使用基本类型实例化泛型</h3><p>请考虑以下参数化类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Pair对象时，不能将基本类型替换为类型参数K或V：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">8</span>, <span class="string">&#x27;a&#x27;</span>);  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>

<p>只能将非基本类型替换为类型参数K和V：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, Character&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">8</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p>此时，Java编译器会自动装箱，将8转为<code>Integer.valueOf(8)</code>，将’a’转为<code>Character(&#39;a&#39;)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, Character&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(Integer.valueOf(<span class="number">8</span>), <span class="keyword">new</span> Character(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="无法创建类型参数的实例"><a href="#无法创建类型参数的实例" class="headerlink" title="无法创建类型参数的实例"></a>无法创建类型参数的实例</h3><p>无法创建类型参数的实例。例如，以下代码导致编译时错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    E elem = <span class="keyword">new</span> E();  <span class="comment">// compile-time error</span></span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为解决方法，您可以通过反射创建类型参数的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(List&lt;E&gt; list, Class&lt;E&gt; cls)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    E elem = cls.newInstance();   <span class="comment">// OK</span></span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以按如下方式调用append方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">append(ls, String.class);</span><br></pre></td></tr></table></figure>

<h3 id="无法声明类型为类型参数的静态字段"><a href="#无法声明类型为类型参数的静态字段" class="headerlink" title="无法声明类型为类型参数的静态字段"></a>无法声明类型为类型参数的静态字段</h3><p>类的静态字段是类的所有非静态对象共享的类级变量。因此，不允许使用类型参数的静态字段。考虑以下类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileDevice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果允许类型参数的静态字段，则以下代码将混淆：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MobileDevice&lt;Smartphone&gt; phone = <span class="keyword">new</span> MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;Pager&gt; pager = <span class="keyword">new</span> MobileDevice&lt;&gt;();</span><br><span class="line">MobileDevice&lt;TabletPC&gt; pc = <span class="keyword">new</span> MobileDevice&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>因为静态字段os由phone、pager、pc所共享的，所以os的实际类型是什么呢？它不能同时是Smartphone、Pager或者TabletPC。因此，无法创建类型参数的静态字段。</p>
<h3 id="无法使用具有参数化类型的强制转换或instanceof"><a href="#无法使用具有参数化类型的强制转换或instanceof" class="headerlink" title="无法使用具有参数化类型的强制转换或instanceof"></a>无法使用具有参数化类型的强制转换或instanceof</h3><p>因为Java编译器会擦除通用代码中的所有类型参数，所以无法验证在运行时使用泛型类型的参数化类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">rtti</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;Integer&gt;) &#123;  <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递给rtti方法的参数化类型集是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S = &#123; ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt; LinkedList&lt;Character&gt;, ... &#125;</span><br></pre></td></tr></table></figure>

<p>运行时不跟踪类型参数，因此无法区分<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>。可以做的最多是使用无界通配符来验证列表是否为ArrayList：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtti</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;?&gt;) &#123;  <span class="comment">// OK; instanceof requires a reifiable type</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，除非通过无界通配符对参数化进行参数化，否则无法强制转换为参数化类型。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>

<p>但是，在某些情况下，编译器知道类型参数始终有效并允许强制转换。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h3 id="无法创建参数化类型的数组"><a href="#无法创建参数化类型的数组" class="headerlink" title="无法创建参数化类型的数组"></a>无法创建参数化类型的数组</h3><p>无法创建参数化类型的数组。例如，以下代码无法编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = <span class="keyword">new</span> List&lt;Integer&gt;[<span class="number">2</span>];  <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>

<p>以下代码说明了将不同类型插入到数组中时会发生什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] strings = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">strings[<span class="number">0</span>] = <span class="string">&quot;hi&quot;</span>;   <span class="comment">// OK</span></span><br><span class="line">strings[<span class="number">1</span>] = <span class="number">100</span>;    <span class="comment">// An ArrayStoreException is thrown.</span></span><br></pre></td></tr></table></figure>

<p>如果使用通用列表尝试相同的操作，则会出现问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] stringLists = <span class="keyword">new</span> List&lt;String&gt;[];  <span class="comment">// compiler error, but pretend it&#x27;s allowed</span></span><br><span class="line">stringLists[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();   <span class="comment">// OK</span></span><br><span class="line">stringLists[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="comment">// An ArrayStoreException should be thrown,</span></span><br><span class="line">                                            <span class="comment">// but the runtime can&#x27;t detect it.</span></span><br></pre></td></tr></table></figure>

<p>如果允许参数化列表数组，则前面的代码将无法抛出所需的ArrayStoreException。</p>
<h3 id="无法创建、捕获或抛出参数化类型的对象"><a href="#无法创建、捕获或抛出参数化类型的对象" class="headerlink" title="无法创建、捕获或抛出参数化类型的对象"></a>无法创建、捕获或抛出参数化类型的对象</h3><p>泛型类不能直接或间接扩展Throwable类。例如，以下类将无法编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Extends Throwable indirectly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/* ... */</span> &#125;    <span class="comment">// compile-time error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Throwable directly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueFullException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123; <span class="comment">/* ... */</span> <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>

<p>方法无法捕获类型参数的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Exception, J&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;J&gt; jobs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (J job : jobs)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;   <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是可以在throws子句中使用类型参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(File file)</span> <span class="keyword">throws</span> T </span>&#123;     <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="无法重载每个重载的形式参数类型擦除到相同原始类型的方法"><a href="#无法重载每个重载的形式参数类型擦除到相同原始类型的方法" class="headerlink" title="无法重载每个重载的形式参数类型擦除到相同原始类型的方法"></a>无法重载每个重载的形式参数类型擦除到相同原始类型的方法</h3><p>类不能有两个重载方法，因为它们在类型擦除后具有相同的签名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;String&gt; strSet)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上述例子将生成编译时错误。</p>
]]></content>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2020/09/30/IO/</url>
    <content><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>本章交要讲解基本的 I/O 。它首先集中在 “I/O流”（I/O Streams），一个强大的概念用于简化 I/O 操作。本文还讲解了序列化，它可以让程序将整个对象转出为流，然后再从流读回来。随后介绍文件 I/O 和文件系统的操作，其中包括了随机访问文件。</p>
<a id="more"></a>

<p>大多数涵盖 I/O流 的类都在<code>java.io</code>包。大多数涵盖文件 I/O 的类都在<code>java.nio.file</code>包。</p>
<h1 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h1><h2 id="字节流-Byte-Streams"><a href="#字节流-Byte-Streams" class="headerlink" title="字节流(Byte Streams)"></a>字节流(Byte Streams)</h2><p>字节流处理原始的二进制数据 I/O。输入输出的是8位字节，相关的类为 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html">InputStream</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html">OutputStream</a>.</p>
<p>字节流的类有许多。为了演示字节流的工作，我们将重点放在文件 I/O字节流 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html">FileInputStream</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileOutputStream.html">FileOutputStream</a> 上。其他种类的字节流用法类似，主要区别在于它们构造的方式，大家可以举一反三。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>下面一例子 CopyBytes， 从 xanadu.txt 文件复制到 outagain.txt，每次只复制一个字节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyBytes</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">		FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;resources/xanadu.txt&quot;</span>);</span><br><span class="line">			out = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;resources/outagain.txt&quot;</span>);</span><br><span class="line">			<span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> ((c = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">				out.write(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">				in.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">				out.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyBytes 花费其大部分时间在简单的循环里面，从输入流每次读取一个字节到输出流，如图所示：</p>
<p><img src="../images/io/byteStream.gif"></p>
<h3 id="记得始终关闭流"><a href="#记得始终关闭流" class="headerlink" title="记得始终关闭流"></a>记得始终关闭流</h3><p>不再需要一个流记得要关闭它，这点很重要。所以，CopyBytes 使用 finally 块来保证即使发生错误两个流还是能被关闭。这种做法有助于避免严重的资源泄漏。</p>
<p>一个可能的错误是，CopyBytes 无法打开一个或两个文件。当发生这种情况，对应解决方案是判断该文件的流是否是其初始 null 值。这就是为什么 CopyBytes 可以确保每个流变量在调用前都包含了一个对象的引用。</p>
<h3 id="何时不使用字节流"><a href="#何时不使用字节流" class="headerlink" title="何时不使用字节流"></a>何时不使用字节流</h3><p>CopyBytes 似乎是一个正常的程序，但它实际上代表了一种低级别的 I/O，你应该避免。因为 xanadu.txt 包含字符数据时，最好的方法是使用字符流，下文会有讨论。字节流应只用于最原始的 I/O。所有其他流类型是建立在字节流之上的。</p>
<h2 id="字符流-Character-Streams"><a href="#字符流-Character-Streams" class="headerlink" title="字符流(Character Streams)"></a>字符流(Character Streams)</h2><p>字符流处理字符数据的 I/O，自动处理与本地字符集转化。</p>
<p>Java 平台存储字符值使用 Unicode 约定。字符流 I/O 会自动将这个内部格式与本地字符集进行转换。在西方的语言环境中，本地字符集通常是 ASCII 的8位超集。</p>
<p>对于大多数应用，字符流的 I/O 不会比 字节流 I/O操作复杂。输入和输出流的类与本地字符集进行自动转换。使用字符的程序来代替字节流可以自动适应本地字符集，并可以准备国际化，而这完全不需要程序员额外的工作。</p>
<p>如果国际化不是一个优先事项，你可以简单地使用字符流类，而不必太注意字符集问题。以后，如果国际化成为当务之急，你的程序可以方便适应这种需求的扩展。见<a href="http://docs.oracle.com/javase/tutorial/i18n/index.html">国际化</a>获取更多信息。</p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><p>字符流类描述在  <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html">Reader</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Writer.html">Writer</a>。而对应文件 I/O ，在 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileReader.html">FileReader</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileWriter.html">FileWriter</a>，下面是一个 CopyCharacters 例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyCharacters</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader inputStream = <span class="keyword">null</span>;</span><br><span class="line">        FileWriter outputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileReader(<span class="string">&quot;resources/xanadu.txt&quot;</span>);</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileWriter(<span class="string">&quot;resources/characteroutput.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">while</span> ((c = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyCharacters 与 CopyBytes 是非常相似的。最重要的区别在于 CopyCharacters  使用的 FileReader 和 FileWriter 用于输入输出，而 CopyBytes 使用 FileInputStream 和FileOutputStream 中的。请注意，这两个CopyBytes和CopyCharacters使用int变量来读取和写入；在 CopyCharacters，int 变量保存在其最后的16位字符值;在 CopyBytes，int 变量保存在其最后的8位字节的值。</p>
<h4 id="字符流使用字节流"><a href="#字符流使用字节流" class="headerlink" title="字符流使用字节流"></a>字符流使用字节流</h4><p>字符流往往是对字节流的“包装”。字符流使用字节流来执行物理I/O，同时字符流处理字符和字节之间的转换。例如，FileReader 使用 FileInputStream，而 FileWriter使用的是 FileOutputStream。</p>
<p>有两种通用的字节到字符的“桥梁”流：InputStreamReader 和 OutputStreamWriter。当没有预包装的字符流类时，使用它们来创建字符流。在 <a href="socket.md">socket</a> 章节中将展示该用法。</p>
<h3 id="面向行的-I-O"><a href="#面向行的-I-O" class="headerlink" title="面向行的 I/O"></a>面向行的 I/O</h3><p>字符 I/O 通常发生在较大的单位不是单个字符。一个常用的单位是行：用行结束符结尾。行结束符可以是回车/换行序列（“<code>\r\n</code>”），一个回车（“<code>\r</code>”），或一个换行符（“<code>\n</code>”）。支持所有可能的行结束符，程序可以读取任何广泛使用的操作系统创建的文本文件。</p>
<p>修改 CopyCharacters 来演示如使用面向行的 I/O。要做到这一点，我们必须使用两个类，<a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html">BufferedReader</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html">PrintWriter</a> 的。我们会在缓冲 I/O 和Formatting 章节更加深入地研究这些类。</p>
<p>该 CopyLines 示例调用 BufferedReader.readLine 和 PrintWriter.println 同时做一行的输入和输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyLines</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		BufferedReader inputStream = <span class="keyword">null</span>;</span><br><span class="line">        PrintWriter outputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;resources/xanadu.txt&quot;</span>));</span><br><span class="line">            outputStream = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;resources/characteroutput.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">            String l;</span><br><span class="line">            <span class="keyword">while</span> ((l = inputStream.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                outputStream.println(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 readLine 按行返回文本行。CopyLines 使用 println 输出带有当前操作系统的行终止符的每一行。这可能与输入文件中不是使用相同的行终止符。</p>
<p>除字符和行之外，有许多方法来构造文本的输入和输出。欲了解更多信息，请参阅 Scanning 和 Formatting。</p>
<h2 id="缓冲流（Buffered-Streams）"><a href="#缓冲流（Buffered-Streams）" class="headerlink" title="缓冲流（Buffered Streams）"></a>缓冲流（Buffered Streams）</h2><p>缓冲流通过减少调用本地 API 的次数来优化的输入和输出。</p>
<p>目前为止，大多数时候我们到看到使用非缓冲 I/O 的例子。这意味着每次读或写请求是由基础 OS 直接处理。这可以使一个程序效率低得多，因为每个这样的请求通常引发磁盘访问，网络活动，或一些其它的操作，而这些是相对昂贵的。</p>
<p>为了减少这种开销，所以 Java 平台实现缓冲 I/O 流。缓冲输入流从被称为缓冲区（buffer）的存储器区域读出数据;仅当缓冲区是空时，本地输入 API 才被调用。同样，缓冲输出流，将数据写入到缓存区，只有当缓冲区已满才调用本机输出 API。</p>
<p>程序可以转换的非缓冲流为缓冲流，这里用非缓冲流对象传递给缓冲流类的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inputStream = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;xanadu.txt&quot;</span>));</span><br><span class="line">outputStream = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;characteroutput.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>用于包装非缓存流的缓冲流类有4个：<a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html">BufferedInputStream</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html">BufferedOutputStream</a> 用于创建字节缓冲字节流, <a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html">BufferedReader</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html">BufferedWriter</a> 用于创建字符缓冲字节流。</p>
<h3 id="刷新缓冲流"><a href="#刷新缓冲流" class="headerlink" title="刷新缓冲流"></a>刷新缓冲流</h3><p>刷新缓冲区是指在某个缓冲的关键点就可以将缓冲输出，而不必等待它填满。</p>
<p>一些缓冲输出类通过一个可选的构造函数参数支持 autoflush（自动刷新）。当自动刷新开启，某些关键事件会导致缓冲区被刷新。例如，自动刷新 PrintWriter 对象在每次调用 println 或者 format 时刷新缓冲区。查看 Formatting 了解更多关于这些的方法。</p>
<p>如果要手动刷新流，请调用其 flush 方法。flush 方法可以用于任何输出流，但对非缓冲流是没有效果的。</p>
<h2 id="扫描（Scanning）和格式化（Formatting）"><a href="#扫描（Scanning）和格式化（Formatting）" class="headerlink" title="扫描（Scanning）和格式化（Formatting）"></a>扫描（Scanning）和格式化（Formatting）</h2><p>扫描和格式化允许程序读取和写入格式化的文本。</p>
<p>I/O 编程通常涉及对人类喜欢的整齐的格式化数据进行转换。为了帮助您与这些琐事，Java 平台提供了两个API。<a href="http://docs.oracle.com/javase/tutorial/essential/io/scanning.html">scanning</a> API 使用分隔符模式将其输入分解为标记。<a href="http://docs.oracle.com/javase/tutorial/essential/io/formatting.html">formatting</a> API 将数据重新组合成格式良好的，人类可读的形式。</p>
<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><h4 id="将其输入分解为标记"><a href="#将其输入分解为标记" class="headerlink" title="将其输入分解为标记"></a>将其输入分解为标记</h4><p>默认情况下，Scanner 使用空格字符分隔标记。（空格字符包括空格，制表符和行终止符。为完整列表，请参阅 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-">Character.isWhitespace</a>）。示例 ScanXan 读取  xanadu.txt 的单个词语并打印他们：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScanXan</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;resources/xanadu.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (s.hasNext()) &#123;</span><br><span class="line">                System.out.println(s.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 Scanner 不是流，但你仍然需要关闭它，以表明你与它的底层流执行完成。</p>
<p>调用 useDelimiter() ,指定一个正则表达式可以使用不同的标记分隔符。例如,假设您想要标记分隔符是一个逗号，后面可以跟空格。你会调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.useDelimiter(&quot;,\\s*&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="转换成独立标记"><a href="#转换成独立标记" class="headerlink" title="转换成独立标记"></a>转换成独立标记</h4><p>该 ScanXan 示例是将所有的输入标记为简单的字符串值。Scanner 还支持所有的 Java 语言的基本类型（除 char），以及 BigInteger 和 BigDecimal 的。此外，数字值可以使用千位分隔符。因此，在一个美国的区域设置，Scanner 能正确地读出字符串“32,767”作为一个整数值。</p>
<p>这里要注意的是语言环境，因为千位分隔符和小数点符号是特定于语言环境。所以，下面的例子将无法正常在所有的语言环境中，如果我们没有指定 scanner 应该用在美国地区工作。可能你平时并不用关心，因为你输入的数据通常来自使用相同的语言环境。可以使用下面的语句来设置语言环境：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s.useLocale(Locale.US);</span><br></pre></td></tr></table></figure>

<p>该 ScanSum 示例是将读取的 double 值列表进行相加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScanSum</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Scanner s = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			s = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;resources/usnumbers.txt&quot;</span>)));</span><br><span class="line">			s.useLocale(Locale.US);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (s.hasNext()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s.hasNextDouble()) &#123;</span><br><span class="line">					sum += s.nextDouble();</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					s.next();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			s.close();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:1032778.74159</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>实现格式化流对象要么是 字符流类的 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html">PrintWriter</a> 的实例，或为字节流类的 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html">PrintStream</a> 的实例。</p>
<p><em>注：对于 PrintStream 对象，你很可能只需要 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out">System.out</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#err">System.err</a>。 （请参阅命令行I/O）当你需要创建一个格式化的输出流，请实例化 PrintWriter，而不是 PrintStream。</em></p>
<p>像所有的字节和字符流对象一样，PrintStream 和 PrintWriter 的实例实现了一套标准的 write 方法用于简单的字节和字符输出。此外，PrintStream 和 PrintWriter 的执行同一套方法，将内部数据转换成格式化输出。提供了两个级别的格式：</p>
<ul>
<li>print 和 println 在一个标准的方式里面格式化独立的值 。</li>
<li>format 用于格式化几乎任何数量的格式字符串值，且具有多种精确选择。</li>
</ul>
<h4 id="print-和-println-方法"><a href="#print-和-println-方法" class="headerlink" title="print 和 println 方法"></a>print 和 println 方法</h4><p>调用 print 或 println 输出使用适当 toString 方法变换后的值的单一值。我们可以看到这 Root 例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> r = Math.sqrt(i);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">&quot;The square root of &quot;</span>);</span><br><span class="line">        System.out.print(i);</span><br><span class="line">        System.out.print(<span class="string">&quot; is &quot;</span>);</span><br><span class="line">        System.out.print(r);</span><br><span class="line">        System.out.println(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        i = <span class="number">5</span>;</span><br><span class="line">        r = Math.sqrt(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;The square root of &quot;</span> + i + <span class="string">&quot; is &quot;</span> + r + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<pre><code>The square root of 2 is 1.4142135623730951.
The square root of 5 is 2.23606797749979.</code></pre>
<p>在 i 和 r 变量格式化了两次：第一次在重载的 print 使用代码，第二次是由Java编译器转换码自动生成，它也利用了 toString。您可以用这种方式格式化任意值，但对于结果没有太多的控制权。</p>
<h4 id="format-方法"><a href="#format-方法" class="headerlink" title="format  方法"></a>format  方法</h4><p>该 format 方法用于格式化基于 format string（格式字符串）  多参。格式字符串包含嵌入了  format specifiers （格式说明)的静态文本;除非使用了格式说明，否则格式字符串输出不变。</p>
<p>格式字符串支持许多功能。在本教程中，我们只介绍一些基础知识。有关完整说明，请参阅 API 规范关于<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">格式字符串语法</a>。</p>
<p>Root2 示例在一个 format 调用里面设置两个值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Root2</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> r = Math.sqrt(i);</span><br><span class="line">        </span><br><span class="line">        System.out.format(<span class="string">&quot;The square root of %d is %f.%n&quot;</span>, i, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：The square root of 2 is 1.414214.</p>
<p>像本例中所使用的格式为：</p>
<ul>
<li>d 格式化整数值为小数</li>
<li>f 格式化浮点值作为小数</li>
<li>n 输出特定于平台的行终止符。</li>
</ul>
<p>这里有一些其他的转换格式：</p>
<ul>
<li>x 格式化整数为十六进制值</li>
<li>s 格式化任何值作为字符串</li>
<li>tB 格式化整数作为一个语言环境特定的月份名称。</li>
</ul>
<p>还有许多其他的转换。</p>
<p><em>注意：除了  <code>%%</code> 和 <code>%n</code>，其他格式符都要匹配参数，否则抛出异常。在 Java 编程语言中，<code>\ n</code>转义总是产生换行符（<code>\u000A</code>）。不要使用<code>\ñ</code>除非你特别想要一个换行符。为了针对本地平台得到正确的行分隔符，请使用<code>％n</code>。</em></p>
<p>除了用于转换，格式说明符可以包含若干附加的元素，进一步定制格式化输出。下面是一个 Format  例子，使用一切可能的一种元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Format</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		 System.out.format(<span class="string">&quot;%f, %1$+020.10f %n&quot;</span>, Math.PI);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：3.141593, +00000003.1415926536 </p>
<p>附加元素都是可选的。下图显示了长格式符是如何分解成元素</p>
<p><img src="../images/io/io-spec.gif"></p>
<p>元件必须出现在显示的顺序。从合适的工作，可选的元素是：</p>
<ul>
<li>Precision(精确)。对于浮点值，这是格式化值的数学精度。对于 s 和其他一般的转换，这是格式化值的最大宽度;该值右截断，如果有必要的。</li>
<li>Width(宽度)。格式化值的最小宽度;如有必要，该值被填充。默认值是左用空格填充。</li>
<li>Flags(标志)指定附加格式设置选项。在 Format 示例中，+ 标志指定的数量应始终标志格式，以及0标志指定0是填充字符。其他的标志包括 - （垫右侧）和（与区域特定的千位分隔符格式号）。请注意，某些标志不能与某些其他标志或与某些转换使用。</li>
<li>Argument Index(参数索引)允许您指定的参数明确匹配。您还可以指定&lt;到相同的参数作为前面的说明一致。这样的例子可以说：<code>System.out.format（“％F，％&lt;+ 020.10f％N”，Math.PI）;</code></li>
</ul>
<h2 id="命令行-I-O"><a href="#命令行-I-O" class="headerlink" title="命令行 I/O"></a>命令行 I/O</h2><p>命令行 I/O 描述了标准流（Standard Streams）和控制台（Console）对象。</p>
<p>Java 支持两种交互方式：标准流（Standard Streams）和通过控制台（Console）。</p>
<h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>标准流是许多操作系统的一项功能。默认情况下，他们从键盘读取输入和写出到显示器。它们还支持对文件和程序之间的 I/O，但该功能是通过命令行解释器，而不是由程序控制。</p>
<p>Java平台支持三种标准流：标准输入（Standard Input, 通过 System.in 访问）、标准输出（Standard Output, 通过System.out 的访问）和标准错误（ Standard Error, 通过System.err的访问）。这些对象被自动定义，并不需要被打开。标准输出和标准错误都用于输出;错误输出允许用户转移经常性的输出到一个文件中，仍然能够读取错误消息。</p>
<p>您可能希望标准流是字符流，但是，由于历史的原因，他们是字节流。 System.out 和System.err 定义为 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html">PrintStream</a> 的对象。虽然这在技术上是一个字节流，PrintStream 利用内部字符流对象来模拟多种字符流的功能。</p>
<p>相比之下，System.in 是一个没有字符流功能的字节流。若要想将标准的输入作为字符流，可以包装 System.in 在 InputStreamReader</p>
<pre><code>InputStreamReader cin = new InputStreamReader(System.in);</code></pre>
<h3 id="Console-控制台"><a href="#Console-控制台" class="headerlink" title="Console (控制台)"></a>Console (控制台)</h3><p>更先进的替代标准流的是 Console 。这个单一，预定义的  <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Console.html">Console</a> 类型的对象，有大部分的标准流提供的功能，另外还有其他功能。Console 对于安全的密码输入特别有用。Console 对象还提供了真正的输入输出字符流，是通过  reader 和 writer 方法实现的。</p>
<p>若程序想使用 Console ，它必须尝试通过调用 System.console() 检索 Console 对象。如果 Console 对象存在，通过此方法将其返回。如果返回 NULL，则 Console 操作是不允许的，要么是因为操作系统不支持他们或者是因为程序本身是在非交互环境中启动的。</p>
<p>Console 对象支持通过读取密码的方法安全输入密码。该方法有助于在两个方面的安全。第一，它抑制回应，因此密码在用户的屏幕是不可见的。第二，readPassword 返回一个字符数组，而不是字符串，所以，密码可以被覆盖，只要它是不再需要就可以从存储器中删除。</p>
<p>Password  例子是一个展示了更改用户的密码原型程序。它演示了几种 Console 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Password</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Console c = System.console();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;No console.&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String login = c.readLine(<span class="string">&quot;Enter your login: &quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> [] oldPassword = c.readPassword(<span class="string">&quot;Enter your old password: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (verify(login, oldPassword)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> noMatch;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> [] newPassword1 = c.readPassword(<span class="string">&quot;Enter your new password: &quot;</span>);</span><br><span class="line">                <span class="keyword">char</span> [] newPassword2 = c.readPassword(<span class="string">&quot;Enter new password again: &quot;</span>);</span><br><span class="line">                noMatch = ! Arrays.equals(newPassword1, newPassword2);</span><br><span class="line">                <span class="keyword">if</span> (noMatch) &#123;</span><br><span class="line">                    c.format(<span class="string">&quot;Passwords don&#x27;t match. Try again.%n&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    change(login, newPassword1);</span><br><span class="line">                    c.format(<span class="string">&quot;Password for %s changed.%n&quot;</span>, login);</span><br><span class="line">                &#125;</span><br><span class="line">                Arrays.fill(newPassword1, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                Arrays.fill(newPassword2, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> (noMatch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.fill(oldPassword, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Dummy change method.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String login, <span class="keyword">char</span>[] password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This method always returns</span></span><br><span class="line">        <span class="comment">// true in this example.</span></span><br><span class="line">        <span class="comment">// Modify this method to verify</span></span><br><span class="line">        <span class="comment">// password according to your rules.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy change method.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String login, <span class="keyword">char</span>[] password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Modify this method to change</span></span><br><span class="line">        <span class="comment">// password according to your rules.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的流程是：</p>
<ul>
<li>尝试检索 Console 对象。如果对象是不可用，中止。</li>
<li>调用 Console.readLine 提示并读取用户的登录名。</li>
<li>调用 Console.readPassword 提示并读取用户的现有密码。</li>
<li>调用 verify 确认该用户被授权可以改变密码。（在本例中，假设 verify 是总是返回true ）</li>
<li>重复下列步骤，直到用户输入的密码相同两次：<ul>
<li>调用 Console.readPassword 两次提示和读一个新的密码。</li>
<li>如果用户输入的密码两次，调用 change 去改变它。 （同样，change  是一个虚拟的方法）</li>
<li>用空格覆盖这两个密码。</li>
</ul>
</li>
<li>用空格覆盖旧的密码。</li>
</ul>
<h2 id="数据流（Data-Streams）"><a href="#数据流（Data-Streams）" class="headerlink" title="数据流（Data Streams）"></a>数据流（Data Streams）</h2><p>Data Streams 处理原始数据类型和字符串值的二进制 I/O。</p>
<p>支持基本数据类型的值（(boolean, char, byte, short, int, long, float, 和 double）以及字符串值的二进制 I/O。所有数据流实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataInput.html">DataInput</a> 或 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataOutput.html">DataOutput</a> 接口。本节重点介绍这些接口的广泛使用的实现，<a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataInputStream.html">DataInputStream</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/DataOutputStream.html">DataOutputStream</a> 类。</p>
<p>DataStreams 例子展示了数据流通过写出的一组数据记录到文件，然后再次从文件中读取这些记录。每个记录包括涉及在发票上的项目，如下表中三个值：</p>
<table>
<thead>
<tr>
<th>记录中顺序</th>
<th>数据类型</th>
<th>数据描述</th>
<th>输出方法</th>
<th>输入方法</th>
<th>示例值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>double</td>
<td>Item price</td>
<td>DataOutputStream.writeDouble</td>
<td>DataInputStream.readDouble</td>
<td>19.99</td>
</tr>
<tr>
<td>2</td>
<td>int</td>
<td>Unit count</td>
<td>DataOutputStream.writeInt</td>
<td>DataInputStream.readInt</td>
<td>12</td>
</tr>
<tr>
<td>3</td>
<td>String</td>
<td>Item description</td>
<td>DataOutputStream.writeUTF</td>
<td>DataInputStream.readUTF</td>
<td>“Java T-Shirt”</td>
</tr>
</tbody></table>
<p>首先，定义了几个常量，数据文件的名称，以及数据。</p>
<pre><code>static final String dataFile = &quot;invoicedata&quot;;

static final double[] prices = &#123; 19.99, 9.99, 15.99, 3.99, 4.99 &#125;;
static final int[] units = &#123; 12, 8, 13, 29, 50 &#125;;
static final String[] descs = &#123;
    &quot;Java T-shirt&quot;,
    &quot;Java Mug&quot;,
    &quot;Duke Juggling Dolls&quot;,
    &quot;Java Pin&quot;,
    &quot;Java Key Chain&quot;
&#125;;</code></pre>
<p>DataStreams  打开一个输出流，提供一个缓冲的文件输出字节流：</p>
<pre><code>out = new DataOutputStream(new BufferedOutputStream(
              new FileOutputStream(dataFile)))</code></pre>
<p>DataStreams 写出记录并关闭输出流：</p>
<pre><code>for (int i = 0; i &lt; prices.length; i ++) &#123;
    out.writeDouble(prices[i]);
    out.writeInt(units[i]);
    out.writeUTF(descs[i]);
&#125;</code></pre>
<p>该 writeUTF 方法写出以 UTF-8 改进形式的字符串值。</p>
<p>现在，DataStreams 读回数据。首先，它必须提供一个输入流，和变量来保存的输入数据。像 DataOutputStream 、DataInputStream 类，必须构造成一个字节流的包装器。</p>
<pre><code>in = new DataInputStream(new
            BufferedInputStream(new FileInputStream(dataFile)));

double price;
int unit;
String desc;
double total = 0.0;</code></pre>
<p>现在，DataStreams 可以读取流里面的每个记录，并在遇到它时将数据报告出来：</p>
<pre><code>try &#123;
    while (true) &#123;
        price = in.readDouble();
        unit = in.readInt();
        desc = in.readUTF();
        System.out.format(&quot;You ordered %d&quot; + &quot; units of %s at $%.2f%n&quot;,
            unit, desc, price);
        total += unit * price;
    &#125;
&#125; catch (EOFException e) &#123;
&#125;</code></pre>
<p>请注意，DataStreams 通过捕获 EOFException 检测文件结束的条件而不是测试无效的返回值。所有实现了 DataInput  的方法都使用 EOFException 类来代替返回值。</p>
<p>还要注意的是 DataStreams 中的各个 write 需要匹配对应相应的 read。它需要由程序员来保证。</p>
<p>DataStreams 使用了一个非常糟糕的编程技术：它使用浮点数来表示的货币价值。在一般情况下，浮点数是不好的精确数值。这对小数尤其糟糕，因为共同值（如 0.1），没有一个二进制的表示。</p>
<p>正确的类型用于货币值是 <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">java.math.BigDecimal</a> 的。不幸的是，BigDecimal 是一个对象的类型，因此它不能与数据流工作。然而，BigDecimal 将与对象流工作，而这部分内容将在下一节讲解。</p>
<h2 id="对象流（Object-Streams）"><a href="#对象流（Object-Streams）" class="headerlink" title="对象流（Object Streams）"></a>对象流（Object Streams）</h2><p>对象流处理对象的二进制 I/O。</p>
<p>正如数据流支持的是基本数据类型的 I/O，对象流支持的对象 I/O。大多数，但不是全部，标准类支持他们的对象的序列化，都需要实现 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html">Serializable</a> 接口。</p>
<p>对象流类包括 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html">ObjectInputStream</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html">ObjectOutputStream</a> 的。这些类实现的 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInput.html">ObjectInput</a> 与 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutput.html">ObjectOutput</a> 的，这些都是 DataInput 和DataOutput 的子接口。这意味着，所有包含在数据流中的基本数据类型 I/O 方法也在对象流中实现了。这样一个对象流可以包含基本数据类型值和对象值的混合。该ObjectStreams 例子说明了这一点。ObjectStreams 创建与 DataStreams 相同的应用程序。首先，价格现在是 <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html">BigDecimal</a> 对象，以更好地代表分数值。其次，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html">Calendar</a> 对象被写入到数据文件中，指示发票日期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStreams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String dataFile = <span class="string">&quot;invoicedata&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> BigDecimal[] prices = &#123; </span><br><span class="line">        <span class="keyword">new</span> BigDecimal(<span class="string">&quot;19.99&quot;</span>), </span><br><span class="line">        <span class="keyword">new</span> BigDecimal(<span class="string">&quot;9.99&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> BigDecimal(<span class="string">&quot;15.99&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> BigDecimal(<span class="string">&quot;3.99&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> BigDecimal(<span class="string">&quot;4.99&quot;</span>) &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] units = &#123; <span class="number">12</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">29</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] descs = &#123; <span class="string">&quot;Java T-shirt&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Java Mug&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Duke Juggling Dolls&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Java Pin&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Java Key Chain&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">        ObjectOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span></span><br><span class="line">                    BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dataFile)));</span><br><span class="line"></span><br><span class="line">            out.writeObject(Calendar.getInstance());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i ++) &#123;</span><br><span class="line">                out.writeObject(prices[i]);</span><br><span class="line">                out.writeInt(units[i]);</span><br><span class="line">                out.writeUTF(descs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span></span><br><span class="line">                    BufferedInputStream(<span class="keyword">new</span> FileInputStream(dataFile)));</span><br><span class="line"></span><br><span class="line">            Calendar date = <span class="keyword">null</span>;</span><br><span class="line">            BigDecimal price;</span><br><span class="line">            <span class="keyword">int</span> unit;</span><br><span class="line">            String desc;</span><br><span class="line">            BigDecimal total = <span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            date = (Calendar) in.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.format (<span class="string">&quot;On %tA, %&lt;tB %&lt;te, %&lt;tY:%n&quot;</span>, date);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    price = (BigDecimal) in.readObject();</span><br><span class="line">                    unit = in.readInt();</span><br><span class="line">                    desc = in.readUTF();</span><br><span class="line">                    System.out.format(<span class="string">&quot;You ordered %d units of %s at $%.2f%n&quot;</span>,</span><br><span class="line">                            unit, desc, price);</span><br><span class="line">                    total = total.add(price.multiply(<span class="keyword">new</span> BigDecimal(unit)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (EOFException e) &#123;&#125;</span><br><span class="line">            System.out.format(<span class="string">&quot;For a TOTAL of: $%.2f%n&quot;</span>, total);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果的 readObject() 不返回预期的对象类型，试图将它转换为正确的类型可能会抛出一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassNotFoundException.html">ClassNotFoundException</a>。在这个简单的例子，这是不可能发生的，所以我们不要试图捕获异常。相反，我们通知编译器，我们已经意识到这个问题，添加 ClassNotFoundException 到主方法的 throws 子句中的。</p>
<h3 id="复杂对象的-I-O"><a href="#复杂对象的-I-O" class="headerlink" title="复杂对象的 I/O"></a>复杂对象的 I/O</h3><p>writeObject 和 readObject 方法简单易用，但它们包含了一些非常复杂的对象管理逻辑。这不像 Calendar 类，它只是封装了原始值。但许多对象包含其他对象的引用。如果 readObject 从流重构一个对象，它必须能够重建所有的原始对象所引用的对象。这些额外的对象可能有他们自己的引用，依此类推。在这种情况下，writeObject 遍历对象引用的整个网络，并将该网络中的所有对象写入流。因此，writeObject 单个调用可以导致大量的对象被写入流。</p>
<p>如下图所示，其中 writeObject 调用名为 a 的单个对象。这个对象包含对象的引用 b和 c，而 b 包含引用 d 和 e。调用 writeObject(a) 写入的不只是一个 a，还包括所有需要重新构成的这个网络中的其他4个对象。当通过 readObject 读回 a 时，其他四个对象也被读回，同时，所有的原始对象的引用被保留。</p>
<p><img src="../images/io/io-trav.gif"></p>
<p>如果在同一个流的两个对象引用了同一个对象会发生什么？流只包含一个对象的一个拷贝，尽管它可以包含任何数量的对它的引用。因此，如果你明确地写一个对象到流两次，实际上只是写入了2此引用。例如，如果下面的代码写入一个对象 ob 两次到流：</p>
<pre><code>Object ob = new Object();
out.writeObject(ob);
out.writeObject(ob);</code></pre>
<p>每个 writeObject 都对应一个 readObject， 所以从流里面读回的代码如下：</p>
<pre><code>Object ob1 = in.readObject();
Object ob2 = in.readObject();</code></pre>
<p>ob1 和 ob2 都是相同对象的引用。</p>
<p>然而，如果一个单独的对象被写入到两个不同的数据流，它被有效地复用 - 一个程序从两个流读回的将是两个不同的对象。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本章例子的源码，可以在 <a href="https://github.com/waylau/essential-java">https://github.com/waylau/essential-java</a> 中 <code>com.waylau.essentialjava.io</code> 包下找到。</p>
<h1 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h1><p>本教程讲述的是 JDK 7 版本以来引入的新的 I/O 机制（也被称为 NIO.2）。</p>
<p>相关的包在 java.nio.file ，其中 java.nio.file.attribute 提供对文件 I/O 以及访问默认文件系统的全面支持。虽然 API 有很多类，但你只需要重点关注几个。你会看到，这个 API 是非常直观和易于使用。</p>
<h2 id="什么是路径（Path）？在其他文件系统的实际是怎么样的？"><a href="#什么是路径（Path）？在其他文件系统的实际是怎么样的？" class="headerlink" title="什么是路径（Path）？在其他文件系统的实际是怎么样的？"></a>什么是路径（Path）？在其他文件系统的实际是怎么样的？</h2><p>文件系统是用某种媒体形式存储和组织文件，一般是一个或多个硬盘驱动器，以这样的方式，它们可以很容易地检索文件。目前使用的大多数文件系统存储文件是以树（或层次）结构。在树的顶部是一个（或多个）根节点。根节点下，有文件和目录（在Microsoft Windows 系统是指文件夹）。每个目录可以包含文件和子目录，而这又可以包含文件和子目录，以此类推，有可能是无限深度。</p>
<h3 id="什么是路径（Path）？"><a href="#什么是路径（Path）？" class="headerlink" title="什么是路径（Path）？"></a>什么是路径（Path）？</h3><p>下图显示了一个包含一个根节点的目录树。Microsoft Windows 支持多个根节点。每个根节点映射到一个卷，如 <code>C:\</code> 或 <code>D:\</code>。 Solaris OS 支持一个根节点，这由斜杠<code>/</code>表示。</p>
<p><img src="../images/io/io-dirStructure.gif"></p>
<p>文件系统通过路径来确定文件。例如，上图 statusReport 在 Solaris OS 描述为：</p>
<pre><code>/home/sally/statusReport</code></pre>
<p>而在 Microsoft Windows 下，描述如下：</p>
<pre><code>C:\home\sally\statusReport</code></pre>
<p>用来分隔目录名称的字符（也称为分隔符）是特定于文件系统的：Solaris OS 中使用正斜杠（/），而 Microsoft Windows 使用反斜杠（\）。</p>
<h3 id="相对或绝对路径？"><a href="#相对或绝对路径？" class="headerlink" title="相对或绝对路径？"></a>相对或绝对路径？</h3><p>路径可以是相对或绝对的。绝对路径总是包含根元素以及找到该文件所需要的完整的目录列表。对于例如，<code> /home/sally/statusReport</code> 是一个绝对路径。所有找到的文件所需的信息都包含在路径字符串里。</p>
<p>相对路径需要与另一路径进行组合才能访问到文件。例如，<code>joe/foo</code> 是一个相对路径,没有更多的信息，程序不能可靠地定位 <code>joe/foo</code> 目录。</p>
<h3 id="符号链接（Symbolic-Links）"><a href="#符号链接（Symbolic-Links）" class="headerlink" title="符号链接（Symbolic Links）"></a>符号链接（Symbolic Links）</h3><p>文件系统对象最典型的是目录或文件。每个人都熟悉这些对象。但是，某些文件系统还支持符号链接的概念。符号链接也被称为符号链接（symlink）或软链接（soft link）。</p>
<p>符号链接是，作为一个引用到另一个文件的特殊文件。在大多数情况下，符号链接对于应用程序来说透明的，符号链接上面的操作会被自动重定向到链接的目标（链接的目标是指该所指向的文件或目录）。当符号链接删除或重命名，在这种情况下，链接本身被删除或重命名，而不是链接的目标。</p>
<p>在下图中，logFile 对于用户来说看起来似乎是一个普通文件，但它实际上是 <code>dir/logs/HomeLogFile</code> 文件的符号链接。HomeLogFile 是链接的目标。</p>
<p><img src="../images/io/io-symlink.gif"></p>
<p>符号链接通常对用户来说是透明。读取或写入符号链接是和读取或写入到任何其他文件或目录是一样的。</p>
<p>解析链接（resolving a link）是指在文件系统中用实际位置取代符号链接。在这个例子中，logFile 解析为 <code>dir/logs/HomeLogFile</code></p>
<p>在实际情况下，大多数文件系统自由使用的符号链接。有时，一不小心创建符号链接会导致循环引用。循环引用是指，当链接的目标点回到原来的链接。循环引用可能是间接的：目录 a 指向目录 b，b 指向目录 c，其中包含的子目录指回目录 a 。当一个程序被递归遍历目录结构时，循环引用可能会导致混乱。但是，这种情况已经做了限制，不会导致程序无限循环。</p>
<p>接下来章节将讨论 Java 文件 I/O 的核心 Path 类。</p>
<h2 id="Path-类"><a href="#Path-类" class="headerlink" title="Path 类"></a>Path 类</h2><p>该 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html">Path</a> 类是从 Java SE 7 开始引入的， 是 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/package-summary.html">java.nio.file</a> 包的主要进入点之一。</p>
<p><em>注：若果 Java SE 7 之前的版本，可以使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/File.html#toPath--">File.toPath</a> 实现 Path 类似的功能</em></p>
<p>Path 类是在文件系统路径的编程表示。Path 对象包含了文件名和目录列表，用于构建路径，以及检查，定位和操作文件。</p>
<p>Path 实例反映了基础平台。在 Solaris OS,路径使用 Solaris 语法（<code>/home/joe/foo</code>）,而在 Microsoft Windows，路径使用 Windows 语法（<code>C:\home\joe\foo</code>）。路径是与系统相关，即 Solaris 文件系统中的路径不能与 Windows 文件系统的路径进行匹配。</p>
<p>对应于该路径的文件或目录可能不存在。您可以创建一个 Path 实例，并以各种方式操纵它：您可以附加到它，提取它的一部分，把它比作其他路径。在适当的时候，可以使用在 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html">Files</a> 类的方法来检查对应路径的文件是否存在，创建文件，打开它，删除它，改变它的权限，等等。</p>
<h3 id="Path-操作"><a href="#Path-操作" class="headerlink" title="Path 操作"></a>Path 操作</h3><p>Path 类包括各种方法，可用于获得关于路径信息，路径的接入元件，路径转换为其它形式，或提取路径的部分。也有用于匹配的路径字符串的方法，也有用于在一个路径去除冗余的方法。这些路径方法，有时也被称为语义操作（syntactic operations），因为是在它们的路径本身进行操作，而不是访问文件系统。</p>
<h4 id="创建路径"><a href="#创建路径" class="headerlink" title="创建路径"></a>创建路径</h4><p>Path 实例包含用于指定文件或目录的位置的信息。在它被定义的时候，一个 Path 上设置了一系列的一个或多个名称。根元素或文件名可能被包括在内，但也不是必需的。Path 可能包含只是一个单一的目录或文件名。</p>
<p>您可以通过 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html">Paths</a>（注意是复数）助手类的 get 方法很容易地创建一个 Path 对象：</p>
<pre><code>Path p1 = Paths.get(&quot;/tmp/foo&quot;);
Path p2 = Paths.get(args[0]);
Path p3 = Paths.get(URI.create(&quot;file:///Users/joe/FileTest.java&quot;));</code></pre>
<p>Paths.get 是下面方式的简写：</p>
<pre><code>Path p4 = FileSystems.getDefault().getPath(&quot;/users/sally&quot;);</code></pre>
<p>下面的例子假设你的 home 目录是 <code>/u/joe</code>,则将创建<code>/u/joe/logs/foo.log</code>, 或若果是 Windows 环境，则为<code>C:\joe\logs\foo.log</code></p>
<h4 id="检索有关一个路径"><a href="#检索有关一个路径" class="headerlink" title="检索有关一个路径"></a>检索有关一个路径</h4><p>你可以把路径作为储存这些名称元素的序列。在目录结构中的最高元素将设在索引为0的目录结构中，而最低元件将设在索引 [n-1]，其中 n 是 Path 的元素个数。方法可用于检索各个元素或使用这些索引 Path 的子序列。</p>
<p>本示例使用下面的目录结构：</p>
<p><img src="../images/io/io-dirStructure.gif"></p>
<p>下面的代码片段定义了一个 Path 实例，然后调用一些方法来获取有关的路径信息：</p>
<pre><code>// None of these methods requires that the file corresponding
// to the Path exists.
// Microsoft Windows syntax
Path path = Paths.get(&quot;C:\\home\\joe\\foo&quot;);

// Solaris syntax
Path path = Paths.get(&quot;/home/joe/foo&quot;);

System.out.format(&quot;toString: %s%n&quot;, path.toString());
System.out.format(&quot;getFileName: %s%n&quot;, path.getFileName());
System.out.format(&quot;getName(0): %s%n&quot;, path.getName(0));
System.out.format(&quot;getNameCount: %d%n&quot;, path.getNameCount());
System.out.format(&quot;subpath(0,2): %s%n&quot;, path.subpath(0,2));
System.out.format(&quot;getParent: %s%n&quot;, path.getParent());
System.out.format(&quot;getRoot: %s%n&quot;, path.getRoot());</code></pre>
<p>下面是 Windows 和 Solaris OS 不同的输出:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>Solaris OS     返回</th>
<th>Microsoft Windows    返回</th>
</tr>
</thead>
<tbody><tr>
<td>toString</td>
<td>/home/joe/foo</td>
<td>C:\home\joe\foo</td>
</tr>
<tr>
<td>getFileName</td>
<td>foo</td>
<td>foo</td>
</tr>
<tr>
<td>getName(0)</td>
<td>home</td>
<td>home</td>
</tr>
<tr>
<td>getNameCount</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>subpath(0,2)</td>
<td>home/joe</td>
<td>home\joe</td>
</tr>
<tr>
<td>getParent</td>
<td>/home/joe</td>
<td>\home\joe</td>
</tr>
<tr>
<td>getRoot</td>
<td>/</td>
<td>C:\</td>
</tr>
</tbody></table>
<p>下面是一个相对路径的例子：</p>
<pre><code>// Solaris syntax
Path path = Paths.get(&quot;sally/bar&quot;);
or
// Microsoft Windows syntax
Path path = Paths.get(&quot;sally\\bar&quot;);</code></pre>
<p>下面是 Windows 和 Solaris OS 不同的输出:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>Solaris OS     返回</th>
<th>Microsoft Windows    返回</th>
</tr>
</thead>
<tbody><tr>
<td>toString</td>
<td>sally/bar</td>
<td>sally\bar</td>
</tr>
<tr>
<td>getFileName</td>
<td>bar</td>
<td>bar</td>
</tr>
<tr>
<td>getName(0)</td>
<td>sally</td>
<td>sally</td>
</tr>
<tr>
<td>getNameCount</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>subpath(0,1)</td>
<td>sally</td>
<td>sally</td>
</tr>
<tr>
<td>getParent</td>
<td>sally</td>
<td>sally</td>
</tr>
<tr>
<td>getRoot</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<h4 id="从-Path-中移除冗余"><a href="#从-Path-中移除冗余" class="headerlink" title="从 Path 中移除冗余"></a>从 Path 中移除冗余</h4><p>许多文件系统使用“.”符号表示当前目录，“..”来表示父目录。您可能有一个 Path 包含冗余目录信息的情况。也许一个服务器配置为保存日志文件在“/dir/logs/.”目录，你想删除后面的“/.”</p>
<p>下面的例子都包含冗余：</p>
<pre><code>/home/./joe/foo
/home/sally/../joe/foo</code></pre>
<p>normalize 方法是删除任何多余的元素，其中包括任何 出现的“.”或“directory/…”。前面的例子规范化为 <code>/home/joe/foo</code></p>
<p>要注意，当它清理一个路径时，normalize 不检查文件系统。这是一个纯粹的句法操作。在第二个例子中，如果 sally 是一个符号链接，删除<code>sally/..</code> 可能会导致不能定位的预期文件。</p>
<p>清理路径的同时，你可以使用 toRealPath 方法来确保结果定位正确的文件。此方法在下一节中描述</p>
<h4 id="转换一个路径"><a href="#转换一个路径" class="headerlink" title="转换一个路径"></a>转换一个路径</h4><p>可以使用3个方法来转换路径。<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toUri--">toUri</a> 将路径转换为可以在浏览器中打开一个字符串，例如：</p>
<pre><code>Path p1 = Paths.get(&quot;/home/logfile&quot;);
// Result is file:///home/logfile
System.out.format(&quot;%s%n&quot;, p1.toUri());</code></pre>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toAbsolutePath--">toAbsolutePath</a> 方法将路径转为绝对路径。如果传递的路径已是绝对的，则返回同一Path 对象。toAbsolutePath 方法可以非常有助于处理用户输入的文件名。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;usage: FileTest file&quot;</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Converts the input string to a Path object.</span></span><br><span class="line">        Path inputPath = Paths.get(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Converts the input Path</span></span><br><span class="line">        <span class="comment">// to an absolute path.</span></span><br><span class="line">        <span class="comment">// Generally, this means prepending</span></span><br><span class="line">        <span class="comment">// the current working</span></span><br><span class="line">        <span class="comment">// directory.  If this example</span></span><br><span class="line">        <span class="comment">// were called like this:</span></span><br><span class="line">        <span class="comment">//     java FileTest foo</span></span><br><span class="line">        <span class="comment">// the getRoot and getParent methods</span></span><br><span class="line">        <span class="comment">// would return null</span></span><br><span class="line">        <span class="comment">// on the original &quot;inputPath&quot;</span></span><br><span class="line">        <span class="comment">// instance.  Invoking getRoot and</span></span><br><span class="line">        <span class="comment">// getParent on the &quot;fullPath&quot;</span></span><br><span class="line">        <span class="comment">// instance returns expected values.</span></span><br><span class="line">        Path fullPath = inputPath.toAbsolutePath();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 toAbsolutePath 方法转换用户输入并返回一个 Path 对于查询时返回是有用的值。此方法不需要文件存在才能正常工作。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#toRealPath-java.nio.file.LinkOption...-">toRealPath</a> 方法返回一个已经存在文件的真实的路径，此方法执行以下其中一个：</p>
<ul>
<li>如果 true 被传递到该方法，同时文件系统支持符号链接，那么该方法可以解析路径中的任何符号链接。</li>
<li>如果 Path 是相对的，它返回一个绝对路径。</li>
<li>如果 Path 中包含任何冗余元素，则返回一个删除冗余元素的路径。</li>
</ul>
<p>若文件不存在或者无法访问,则方法抛出异常。可以捕捉处理异常：</p>
<pre><code>try &#123;
    Path fp = path.toRealPath();
&#125; catch (NoSuchFileException x) &#123;
    System.err.format(&quot;%s: no such&quot; + &quot; file or directory%n&quot;, path);
    // Logic for case when file doesn&#39;t exist.
&#125; catch (IOException x) &#123;
    System.err.format(&quot;%s%n&quot;, x);
    // Logic for other sort of file error.
&#125;</code></pre>
<h4 id="连接两个路径"><a href="#连接两个路径" class="headerlink" title="连接两个路径"></a>连接两个路径</h4><p>可以使用 resolve 连接两个路径。你传递一个局部路径（partial path, 不包括一个根元素的路径），可以将局部路径追加到原始的路径。</p>
<p>例如，请考虑下面的代码片段：</p>
<pre><code>// Solaris
Path p1 = Paths.get(&quot;/home/joe/foo&quot;);
// Result is /home/joe/foo/bar
System.out.format(&quot;%s%n&quot;, p1.resolve(&quot;bar&quot;));

or

// Microsoft Windows
Path p1 = Paths.get(&quot;C:\\home\\joe\\foo&quot;);
// Result is C:\home\joe\foo\bar
System.out.format(&quot;%s%n&quot;, p1.resolve(&quot;bar&quot;));</code></pre>
<p>传递相对路径到 resolve 方法返回路径中的传递路径：</p>
<pre><code>// Result is /home/joe
Paths.get(&quot;foo&quot;).resolve(&quot;/home/joe&quot;);</code></pre>
<h4 id="在两个路径间创建路径"><a href="#在两个路径间创建路径" class="headerlink" title="在两个路径间创建路径"></a>在两个路径间创建路径</h4><p>文件 I/O 代码中的常见的需求是从路径能在不同的文件系统中兼容。可以使用relativize 方法满足这一点。新的路径是相对于原来的路径。</p>
<p>例如，定义为 joe 和 sally 相对路径：</p>
<pre><code>Path p1 = Paths.get(&quot;joe&quot;);
Path p2 = Paths.get(&quot;sally&quot;);</code></pre>
<p>在没有任何其他信息的，假定  joe 和 sally 是同一级别的节点。从 joe 导航到 sally，你会希望首先导航上一级父节点，然后向下找到 sally：</p>
<pre><code>// Result is ../sally
Path p1_to_p2 = p1.relativize(p2);
// Result is ../joe
Path p2_to_p1 = p2.relativize(p1);</code></pre>
<p>下面是复杂点的例子:</p>
<pre><code>Path p1 = Paths.get(&quot;home&quot;);
Path p3 = Paths.get(&quot;home/sally/bar&quot;);
// Result is sally/bar
Path p1_to_p3 = p1.relativize(p3);
// Result is ../..
Path p3_to_p1 = p3.relativize(p1);</code></pre>
<p>Copy 是个完整的使用 relativize 和 resolve  的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if okay to overwrite a  file (&quot;cp -i&quot;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">okayToOverwrite</span><span class="params">(Path file)</span> </span>&#123;</span><br><span class="line">        String answer = System.console().readLine(<span class="string">&quot;overwrite %s (yes/no)? &quot;</span>, file);</span><br><span class="line">        <span class="keyword">return</span> (answer.equalsIgnoreCase(<span class="string">&quot;y&quot;</span>) || answer.equalsIgnoreCase(<span class="string">&quot;yes&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy source file to target location. If &#123;<span class="doctag">@code</span> prompt&#125; is true then</span></span><br><span class="line"><span class="comment">     * prompt user to overwrite target if it exists. The &#123;<span class="doctag">@code</span> preserve&#125;</span></span><br><span class="line"><span class="comment">     * parameter determines if file attributes should be copied/preserved.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(Path source, Path target, <span class="keyword">boolean</span> prompt, <span class="keyword">boolean</span> preserve)</span> </span>&#123;</span><br><span class="line">        CopyOption[] options = (preserve) ?</span><br><span class="line">            <span class="keyword">new</span> CopyOption[] &#123; COPY_ATTRIBUTES, REPLACE_EXISTING &#125; :</span><br><span class="line">            <span class="keyword">new</span> CopyOption[] &#123; REPLACE_EXISTING &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!prompt || Files.notExists(target) || okayToOverwrite(target)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Files.copy(source, target, options);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                System.err.format(<span class="string">&quot;Unable to copy: %s: %s%n&quot;</span>, source, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A &#123;<span class="doctag">@code</span> FileVisitor&#125; that copies a file-tree (&quot;cp -r&quot;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeCopier</span> <span class="keyword">implements</span> <span class="title">FileVisitor</span>&lt;<span class="title">Path</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Path source;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Path target;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> prompt;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> preserve;</span><br><span class="line"></span><br><span class="line">        TreeCopier(Path source, Path target, <span class="keyword">boolean</span> prompt, <span class="keyword">boolean</span> preserve) &#123;</span><br><span class="line">            <span class="keyword">this</span>.source = source;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">            <span class="keyword">this</span>.prompt = prompt;</span><br><span class="line">            <span class="keyword">this</span>.preserve = preserve;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// before visiting entries in a directory we copy the directory</span></span><br><span class="line">            <span class="comment">// (okay if directory already exists).</span></span><br><span class="line">            CopyOption[] options = (preserve) ?</span><br><span class="line">                <span class="keyword">new</span> CopyOption[] &#123; COPY_ATTRIBUTES &#125; : <span class="keyword">new</span> CopyOption[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            Path newdir = target.resolve(source.relativize(dir));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Files.copy(dir, newdir, options);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileAlreadyExistsException x) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                System.err.format(<span class="string">&quot;Unable to create: %s: %s%n&quot;</span>, newdir, x);</span><br><span class="line">                <span class="keyword">return</span> SKIP_SUBTREE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span>&#123;</span><br><span class="line">            copyFile(file, target.resolve(source.relativize(file)),</span><br><span class="line">                     prompt, preserve);</span><br><span class="line">            <span class="keyword">return</span> CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// fix up modification time of directory when done</span></span><br><span class="line">            <span class="keyword">if</span> (exc == <span class="keyword">null</span> &amp;&amp; preserve) &#123;</span><br><span class="line">                Path newdir = target.resolve(source.relativize(dir));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    FileTime time = Files.getLastModifiedTime(dir);</span><br><span class="line">                    Files.setLastModifiedTime(newdir, time);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    System.err.format(<span class="string">&quot;Unable to copy all attributes to: %s: %s%n&quot;</span>, newdir, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFileFailed</span><span class="params">(Path file, IOException exc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (exc <span class="keyword">instanceof</span> FileSystemLoopException) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;cycle detected: &quot;</span> + file);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.format(<span class="string">&quot;Unable to copy: %s: %s%n&quot;</span>, file, exc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;java Copy [-ip] source... target&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;java Copy -r [-ip] source-dir... target&quot;</span>);</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> recursive = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> prompt = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> preserve = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process options</span></span><br><span class="line">        <span class="keyword">int</span> argi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (argi &lt; args.length) &#123;</span><br><span class="line">            String arg = args[argi];</span><br><span class="line">            <span class="keyword">if</span> (!arg.startsWith(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (arg.length() &lt; <span class="number">2</span>)</span><br><span class="line">                usage();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arg.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = arg.charAt(i);</span><br><span class="line">                <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span> : recursive = <span class="keyword">true</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span> : prompt = <span class="keyword">true</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span> : preserve = <span class="keyword">true</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span> : usage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            argi++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remaining arguments are the source files(s) and the target location</span></span><br><span class="line">        <span class="keyword">int</span> remaining = args.length - argi;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">2</span>)</span><br><span class="line">            usage();</span><br><span class="line">        Path[] source = <span class="keyword">new</span> Path[remaining-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (remaining &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            source[i++] = Paths.get(args[argi++]);</span><br><span class="line">            remaining--;</span><br><span class="line">        &#125;</span><br><span class="line">        Path target = Paths.get(args[argi]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if target is a directory</span></span><br><span class="line">        <span class="keyword">boolean</span> isDir = Files.isDirectory(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy each source file/directory to target</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;source.length; i++) &#123;</span><br><span class="line">            Path dest = (isDir) ? target.resolve(source[i].getFileName()) : target;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (recursive) &#123;</span><br><span class="line">                <span class="comment">// follow links when copying files</span></span><br><span class="line">                EnumSet&lt;FileVisitOption&gt; opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);</span><br><span class="line">                TreeCopier tc = <span class="keyword">new</span> TreeCopier(source[i], dest, prompt, preserve);</span><br><span class="line">                Files.walkFileTree(source[i], opts, Integer.MAX_VALUE, tc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// not recursive so source must not be a directory</span></span><br><span class="line">                <span class="keyword">if</span> (Files.isDirectory(source[i])) &#123;</span><br><span class="line">                    System.err.format(<span class="string">&quot;%s: is a directory%n&quot;</span>, source[i]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                copyFile(source[i], dest, prompt, preserve);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较两个路径"><a href="#比较两个路径" class="headerlink" title="比较两个路径"></a>比较两个路径</h4><p>Path 类支持 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#equals-java.lang.Object-">equals</a>，从而使您能够测试两个路径是否相等。<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#startsWith-java.nio.file.Path-">startsWith</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html#endsWith-java.nio.file.Path-">endsWith</a> 方法，可以测试路径中是否有特定的字符串开头或者结尾。这些方法很容易使用。 例如：</p>
<pre><code>Path path = ...;
Path otherPath = ...;
Path beginning = Paths.get(&quot;/home&quot;);
Path ending = Paths.get(&quot;foo&quot;);

if (path.equals(otherPath)) &#123;
    // equality logic here
&#125; else if (path.startsWith(beginning)) &#123;
    // path begins with &quot;/home&quot;
&#125; else if (path.endsWith(ending)) &#123;
    // path ends with &quot;foo&quot;
&#125;</code></pre>
<p>Path 类实现了 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html">Iterable</a> 接口。 iterator 方法返回一个对象，使您可以遍历路径中的元素名。返回的第一个元素是最接近目录树的根。下面的代码片段遍历路径，打印每个name 元素：</p>
<pre><code>Path path = ...;
for (Path name: path) &#123;
    System.out.println(name);
&#125;</code></pre>
<p>该类同时还是实现了  <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html">Comparable</a> 接口，可以 compareTo 方法对于排序过的 Path 对象进行比较 。</p>
<p>你也可以把 Path 对象到放到 Collection。见集合线索有关此强大功能的更多信息。</p>
<p>如果您想验证两个 Path 对象是否定位同一个文件，可以使用 isSameFile 方法。</p>
<h2 id="File-文件-操作"><a href="#File-文件-操作" class="headerlink" title="File(文件)操作"></a>File(文件)操作</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html">Files</a> 类是 java.nio.file 包的其他主要入口。这个类提供了一组丰富的静态方法，用于读取、写入和操作文件和目录。Files 方法可以作用于 Path 对象实例。要进入下章节的学习，首先要建立如下概念：</p>
<h3 id="释放系统资源"><a href="#释放系统资源" class="headerlink" title="释放系统资源"></a>释放系统资源</h3><p>有许多使用此 API 的资源，如流或信道的，都实现或者继承了 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html">java.io.Closeable</a> 接口。一个 Closeable 的资源需在不用时调用 close 方法以释放资源。忘记关闭资源对应用程序的性能可能产生负面影响。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>所有方法访问文件系统都可以抛出 IOException。最佳实践是通过 <code>try-with-resources</code> 语句（Java SE 7 引入该语句）来捕获异常。</p>
<p>使用 <code>try-with-resources</code> 语句的好处是，在资源不需要时，编译器会自动生成的代码以关闭资源。下面的代码显示了如何用：</p>
<pre><code>Charset charset = Charset.forName(&quot;US-ASCII&quot;);
String s = ...;
try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) &#123;
    writer.write(s, 0, s.length());
&#125; catch (IOException x) &#123;
    System.err.format(&quot;IOException: %s%n&quot;, x);
&#125;</code></pre>
<p>或者，你可以使用  try-catch-finally 语句，在 finally 块记得关闭它们。例子如下：</p>
<pre><code>Charset charset = Charset.forName(&quot;US-ASCII&quot;);
String s = ...;
BufferedWriter writer = null;
try &#123;
    writer = Files.newBufferedWriter(file, charset);
    writer.write(s, 0, s.length());
&#125; catch (IOException x) &#123;
    System.err.format(&quot;IOException: %s%n&quot;, x);
&#125; finally &#123;
    if (writer != null) writer.close();
&#125;</code></pre>
<p>除了 IOException 异常，许多异常都继承了 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html">FileSystemException</a>。这个类有一些有用的方法，如返回所涉及的文件 (<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getFile--">getFile</a>) ，详细信息字符串（<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getMessage--">getMessage</a>），文件系统操作失败的原因（<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getReason--">getReason</a>），以及所涉及的“其他”的文件，如果有的话（<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystemException.html#getOtherFile--">getOtherFile</a>）。</p>
<p>下面的代码片段显示了 getFile 方法的使用：</p>
<pre><code>try (...) &#123;
    ...    
&#125; catch (NoSuchFileException x) &#123;
    System.err.format(&quot;%s does not exist\n&quot;, x.getFile());
&#125;</code></pre>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>Files 方法可以接受 可变参数，用法如</p>
<pre><code>Path Files.move(Path, Path, CopyOption...)</code></pre>
<p>可变参数可以用逗号隔开的数组 (CopyOption[]) ，用法：</p>
<pre><code>import static java.nio.file.StandardCopyOption.*;

Path source = ...;
Path target = ...;
Files.move(source,
           target,
           REPLACE_EXISTING,
           ATOMIC_MOVE);</code></pre>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>几个 Files 的方法，如 move，是可以在某些文件系统上执行某些原子操作的。</p>
<p>原子文件操作是不能被中断或不能进行“部分”的操作。整个操作要不就执行不要就操作失败。在多个进程中操作相同的文件系统，需要保证每个进程访问一个完整的文件，这是非常重要的。</p>
<h3 id="方法链"><a href="#方法链" class="headerlink" title="方法链"></a>方法链</h3><p>许多文件 I/O 支持方法链。例如：</p>
<pre><code>String value = Charset.defaultCharset().decode(buf).toString();
UserPrincipal group =
    file.getFileSystem().getUserPrincipalLookupService().
         lookupPrincipalByName(&quot;me&quot;);</code></pre>
<p>该技术可以生成紧凑的代码，使您避免声明不需要临时变量。           </p>
<h3 id="什么是-Glob？"><a href="#什么是-Glob？" class="headerlink" title="什么是 Glob？"></a>什么是 Glob？</h3><p>Glob 是一种模式，它使用通配符来指定文件或者目录名名称。例如：<code>*.java</code>就是一个简单的 Glob，它指定了所有扩展名为“java”的文件。其中</p>
<ul>
<li><code>*</code>表示“任意的字符或字符组成字符串”</li>
<li><code>**</code>原理类似于<code>*</code>，但可以越过目录。此语法通常用于匹配的完整路径。</li>
<li><code>?</code>表示“任意单个字符”</li>
<li>大括号指定子模式的集合。 例如：<ul>
<li>{sun,moon,stars} 匹配 “sun”, “moon”, 或 “stars”</li>
<li>{temp*,tmp*} 匹配所有 “temp” 或 “tmp” 开头的字符串</li>
</ul>
</li>
<li>方括号传达了单个字符集合，或者使用连字符（-）时的字符的范围。 例如：<ul>
<li>[aeiou]匹配任意小写元音。</li>
<li>[0-9]匹配任意数字。</li>
<li>[A-Z]匹配任意大写字母。</li>
<li>[a-z,A-Z]匹配任何大写或小写字母。</li>
</ul>
</li>
</ul>
<p>在方括号中，<code>*</code>，<code>？</code>，和<code>\</code>与自身匹配。</p>
<ul>
<li>所有其他字符与自身匹配。</li>
<li>要匹配<code>*</code> ,<code>?</code>或其他特殊字符，您可以用反斜杠字符转义<code>\</code>。例如：<code>\\</code>匹配一个反斜杠，<code>\？</code>匹配问号。</li>
</ul>
<p>下面是一些 Glob 的一些例子：</p>
<ul>
<li><code>*.html</code> - 匹配结尾以 .html 的所有字符串</li>
<li><code>???</code> - 匹配所有的字符串恰好有三个字母或数字</li>
<li><code>*[0-9]*</code> - 匹配含有数字值的所有字符串</li>
<li><code>*.&#123;htm,html,pdf&#125;</code> - 匹配具有的 .htm 或 .html 或 .pdf 结尾的字符串</li>
<li><code>a?*.java？</code> - 匹配 a 开头随后跟至少一个字母或数字，并以 .java 结尾的字符串</li>
<li><code>&#123;foo*,*[0-9]*&#125;</code> - 匹配任何以 foo 开头的或包含数值的字符串</li>
</ul>
<p>Glob 模式源于Unix操作系统，Unix 提供了一个“global命令”,它可以缩写为glob。Glob 模式与正则表达式类似，但它的功能有限。 详见 FileSystem 类的 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">getPathMatcher</a> 。</p>
<h3 id="链接意识"><a href="#链接意识" class="headerlink" title="链接意识"></a>链接意识</h3><p>Files 方法在遇到符号链接时，要检测做什么，或者提供启用怎样的配置选项。</p>
<h2 id="检查文件或目录"><a href="#检查文件或目录" class="headerlink" title="检查文件或目录"></a>检查文件或目录</h2><h3 id="验证文件或者目录是否存在"><a href="#验证文件或者目录是否存在" class="headerlink" title="验证文件或者目录是否存在"></a>验证文件或者目录是否存在</h3><p>使用 exists(Path, LinkOption…) 和 the notExists(Path, LinkOption…) 方法。注意 !Files.exists(path) 不同等于 Files.notExists(path)。当您在验证文件是否存在，三种可能的结果：</p>
<ul>
<li>该文件被确认存在</li>
<li>该文件被证实不存在的</li>
<li>该文件的状态未知。当程序没有访问该文件时，可能会发生此结果。</li>
</ul>
<p>若 exists 和 notExists 同时返回 false，则该文件的是否存在不能被验证。</p>
<h3 id="检查是否可访问"><a href="#检查是否可访问" class="headerlink" title="检查是否可访问"></a>检查是否可访问</h3><p>使用 isReadable(Path), isWritable(Path), 和 isExecutable(Path) 来验证程序是否可以访问文件。</p>
<p>下面的代码片段验证一个特定的文件是否存在，以及该程序能够执行该文件：</p>
<pre><code>Path file = ...;
boolean isRegularExecutableFile = Files.isRegularFile(file) &amp;
         Files.isReadable(file) &amp; Files.isExecutable(file);</code></pre>
<p><em>注：一旦这些方法中的任何一个完成，就无法再保证文件是可以访问的了。所以，在许多应用程序中的一个共同安全缺陷是先执行一个检查，然后访问该文件。有关更多信息，使用搜索引擎查找 TOCTTOU</em> </p>
<h3 id="检查是否有两个路径定位了相同的文件"><a href="#检查是否有两个路径定位了相同的文件" class="headerlink" title="检查是否有两个路径定位了相同的文件"></a>检查是否有两个路径定位了相同的文件</h3><p>在使用符号链接的文件系统中，就可能有两个定位到相同文件的不同的路径。使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#isSameFile-java.nio.file.Path-java.nio.file.Path-">isSameFile(Path, Path)</a> 方法比较两个路径，以确定它们在该文件系统上是否定位为同一个文件。 例如：</p>
<pre><code>Path p1 = ...;
Path p2 = ...;

if (Files.isSameFile(p1, p2)) &#123;
    // Logic when the paths locate the same file
&#125;</code></pre>
<h2 id="删除文件或目录"><a href="#删除文件或目录" class="headerlink" title="删除文件或目录"></a>删除文件或目录</h2><p>您可以删除文件，目录或链接。如果是符号链接，则该链接被删除后，不会删除所链接的目标。对于目录来说，该目录必须是空的，否则删除失败。</p>
<p>Files 类提供了两个删除方法。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#delete-java.nio.file.Path-">delete(Path)</a> 方法删除文件或者删除失败将引发异常。例如，如果文件不存在就抛出 NoSuchFileException。您可以捕获该异常，以确定为什么删除失败，如下所示：</p>
<pre><code>try &#123;
    Files.delete(path);
&#125; catch (NoSuchFileException x) &#123;
    System.err.format(&quot;%s: no such&quot; + &quot; file or directory%n&quot;, path);
&#125; catch (DirectoryNotEmptyException x) &#123;
    System.err.format(&quot;%s not empty%n&quot;, path);
&#125; catch (IOException x) &#123;
    // File permission problems are caught here.
    System.err.println(x);
&#125;</code></pre>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#deleteIfExists-java.nio.file.Path-">deleteIfExists(Path)</a> 同样是删除文件，但在文件不存在时不会抛出异常。这在多个线程处理删除文件又不想抛出异常是很有用的。</p>
<h2 id="复制文件或目录"><a href="#复制文件或目录" class="headerlink" title="复制文件或目录"></a>复制文件或目录</h2><p>使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-">copy(Path, Path, CopyOption…)</a> 方法。如果目标文件已经存在了，则复制就会失败，除非指定  REPLACE_EXISTING 选项来替换已经存在的文件。</p>
<p>目录可以被复制。但是，目录内的文件不会被复制，因此新目录是空的，即使原来的目录中包含的文件。</p>
<p>当复制一个符号链接，链接的目标被复制。如果你想复制链接本身而不是链接的内容，请指定的 NOFOLLOW_LINKS 或 REPLACE_EXISTING 选项。</p>
<p>这种方法需要一个可变参数的参数。下面 StandardCopyOption 和 LinkOption 枚举是支持的：</p>
<ul>
<li>REPLACE_EXISTING - 执行复制，即使目标文件已经存在。如果目标是一个符号链接，则链接本身被复制（而不是链接所指向的目标）。如果目标是一个非空目录，复制失败抛出 FileAlreadyExistsException。</li>
<li>COPY_ATTRIBUTES - 复制文件属性复制到目标文件。所支持的准确的文件属性是和文件系统和平台相关的，但是 last-modified-time  是支持跨平台的，将被复制到目标文件。</li>
<li>NOFOLLOW_LINKS - 指示符号链接不应该被跟随。如果要复制的文件是一个符号链接，该链接被复制（而不是链接的目标）</li>
</ul>
<p>下面演示了 copy  的用法：</p>
<pre><code>import static java.nio.file.StandardCopyOption.*;
...
Files.copy(source, target, REPLACE_EXISTING);</code></pre>
<p>其他方法还包括，<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...-">copy(InputStream, Path, CopyOptions…) </a> 方法可用于所有字节从输入流复制到文件中。 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.io.OutputStream-">copy(Path, OutputStream)</a> 方法可用于所有字节从一个文件复制到输出流中。</p>
<h2 id="移动一个文件或目录"><a href="#移动一个文件或目录" class="headerlink" title="移动一个文件或目录"></a>移动一个文件或目录</h2><p>使用 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-">move(Path, Path, CopyOption…)</a>  方法。如果目标文件已经存在，则移动失败，除非指定了 REPLACE_EXISTING  选项</p>
<p>空目录可以移动。如果该目录不为空，那么在移动时可以选择只移动该目录而不移动该目录中的内容。在 UNIX 系统中，移动在同一分区内的目录一般包括重命名的目录。在这种情况下，即使该目录包含文件，这方法仍然可行。</p>
<p>该方法采用可变参数的参数 - 以下 StandardCopyOption 枚举的支持：</p>
<ul>
<li>REPLACE_EXISTING - 执行移动，即使目标文件已经存在。如果目标是一个符号链接，符号链接被替换，但它指向的目标是不会受到影响。</li>
<li>ATOMIC_MOVE - 此举为一个原子文件操作。如果文件系统不支持原子移动，将引发异常。在 ATOMIC_MOVE 选项下，将文件移动到一个目录时，可以保证任何进程访问目录时都看到的是一个完整的文件。</li>
</ul>
<p>下面介绍如何使用 move 方法：</p>
<pre><code>import static java.nio.file.StandardCopyOption.*;
...
Files.move(source, target, REPLACE_EXISTING);</code></pre>
<h2 id="管理元数据（文件和文件存储的属性）"><a href="#管理元数据（文件和文件存储的属性）" class="headerlink" title="管理元数据（文件和文件存储的属性）"></a>管理元数据（文件和文件存储的属性）</h2><h2 id="阅读，写作，和创建文件"><a href="#阅读，写作，和创建文件" class="headerlink" title="阅读，写作，和创建文件"></a>阅读，写作，和创建文件</h2><h2 id="随机访问文件"><a href="#随机访问文件" class="headerlink" title="随机访问文件"></a>随机访问文件</h2><h2 id="创建和读取目录"><a href="#创建和读取目录" class="headerlink" title="创建和读取目录"></a>创建和读取目录</h2><h2 id="链接，符号或否则"><a href="#链接，符号或否则" class="headerlink" title="链接，符号或否则"></a>链接，符号或否则</h2><h2 id="走在文件树"><a href="#走在文件树" class="headerlink" title="走在文件树"></a>走在文件树</h2><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><h2 id="看目录的更改"><a href="#看目录的更改" class="headerlink" title="看目录的更改"></a>看目录的更改</h2><h2 id="其他有用的方法"><a href="#其他有用的方法" class="headerlink" title="其他有用的方法"></a>其他有用的方法</h2><h2 id="传统的文件I-O代码"><a href="#传统的文件I-O代码" class="headerlink" title="传统的文件I/ O代码"></a>传统的文件I/ O代码</h2>]]></content>
  </entry>
  <entry>
    <title>Scala编程练习</title>
    <url>/2020/10/04/Scala%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>一、实验名称<br>Scala编程练习<br>二、实验目的</p>
<a id="more"></a>
<p>1.掌握Scala语言的基本语法、数据结构和控制结构；<br>2.掌握面向对象编程的基础知识，能够编写自定义类和特质；<br>3.掌握函数式编程的基础知识，能够熟练定义匿名函数。熟悉Scala的容器类库的基本层次结构，熟练使用常用的容器类进行数据；<br>4.熟练掌握Scala的REPL运行模式和编译运行方法。<br>三、实验平台<br>已经配置完成的Scala开发环境。Scala版本为2.11.8.</p>
<p>四、实验内容与结果分析</p>
<ol>
<li>计算级数<br>请用脚本的方式编程计算并输出下列级数的前n项之和Sn，直到Sn刚好大于或等于q为止，其中q为大于0的整数，其值通过键盘输入。</li>
</ol>
<p>例如，若q的值为50.0，则输出应为：Sn=50.416695。请将源文件保存为exercise2-1.scala，在REPL模式下测试运行，测试样例：q=1时，Sn=2；q=30时，Sn=30.891459；q=50时，Sn=50.416695。<br>要求：使用三种方式完成<br>①repl环境下一行一句运行<br>②脚本文件test1.scala存放不带有对象和main的所有代码，在REPL中:load运行<br>③脚本文件test2.scala，存放带有对象和main的所有代码，在Linux Shell中编译scalac，打包java\scala运行</p>
<p>2 使用scala语言编程输出九九乘法表</p>
<ol start="3">
<li>统计List列表中中单词出现的频率，例如：<br>val list1=List(“I am a student”,” love database”,”Hadoop is good”,”spark is good”)<br>输出结果为：键值对形式输出。</li>
</ol>
<p>4 统计学生成绩（教材P73）</p>
<p>四、心得体会<br>     通过这次实验我学会了：</p>
<ol>
<li>统计单词出现的频率用可变包import collection.mutable.Map 方便之后加入更多的键值对。</li>
<li>用flatMap拍扁映射操作可以把list1中的句子分割成一个一个的单词，其方法体中应该为{a=&gt;a.split(“ ”)},我在做的时候一直没有理解对split函数的意思，导致出现了如上图所示的错误做法，后面通过问同学后及时更正。</li>
<li>用var m=Map.empty[String,Int]先定义，然后函数val f:String=&gt;Unit={w=&gt;if(m.contains(某个字母)) m(某个字母)+=1 else m(某个字母) =1}</li>
<li>：load -v 文件名 是在scala环境下运行的，之前一直在家目录下运行，发现没有用。</li>
</ol>
<ol start="5">
<li><p>用FileZilla这款软件的时候，发现站点管理器中的IP地址不对时，用ifconfig指令进行查询即可。 </p>
</li>
<li><p>20.10.8</p>
</li>
<li><p>单词一定要拼写正确，可以免去很多不必要的错误，节省大量的时间。</p>
</li>
<li><p>用xrandr -s 1280x800调整ubuntu界面大小</p>
</li>
</ol>
<p>注：以上内容将发布到<a href="https://ec-company.github.io/%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%AD%E3%80%82">https://ec-company.github.io/我自己的博客中。</a></p>
]]></content>
  </entry>
  <entry>
    <title>关于区块链</title>
    <url>/2020/10/07/%E5%85%B3%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<p>定义：<br>区块链是一个信息技术领域的术语。从本质上讲，它是一个共享数据库，</p>
<a id="more"></a>存储于其中的数据或信息，具有“不可伪造”“全程留痕”“可以追溯”“公开透明”“集体维护”等特征。基于这些特征，区块链技术奠定了坚实的“信任”基础，创造了可靠的“合作”机制，具有广阔的运用前景。2019年1月10日，国家互联网信息办公室发布《区块链信息服务管理规定》   。2019年10月24日，在中央政治局第十八次集体学习时，习近平总书记强调，“把区块链作为核心技术自主创新的重要突破口”“加快推动区块链技术和产业创新发展”。“区块链”已走进大众视野，成为社会的关注焦点。
<p>2019年12月2日，该词入选《咬文嚼字》2019年十大流行语</p>
<p>起源：<br>    区块链起源于比特币，2008年11月1日，一位自称中本聪(Satoshi Nakamoto)人发表了《比特币:一种点对点的电子现金系统》一文  ，阐述了基于P2P网络技术、加密技术、时间戳技术、区块链技术等的电子现金系统的构架理念，这标志着比特币的诞生。两个月后理论步入实践，2009年1月3日第一个序号为0的创世区块诞生。几天后2009年1月9日出现序号为1的区块，并与序号为0的创世区块相连接形成了链，标志着区块链的诞生   。<br>近年来，世界对比特币的态度起起落落，但作为比特币底层技术之一的区块链技术日益受到重视。在比特币形成过程中，区块是一个一个的存储单元，记录了一定时间内各个区块节点全部的交流信息。各个区块之间通过随机散列(也称哈希算法)实现链接，后一个区块包含前一个区块的哈希值，随着信息交流的扩大，一个区块与一个区块相继接续，形成的结果就叫区块链。</p>
<p>类型：<br>1.公有区块链<br>     公有区块链（Public Block Chains)是指：世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。公有区块链是最早的区块链，也是应用最广泛的区块链，各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上有且仅有一条该币种对应的区块链。<br>2.联合（行业）区块链<br>     行业区块链（Consortium Block Chains)：由某个群体内部指定多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程），其他接入节点可以参与交易，但不过问记账过程(本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点），其他任何人可以通过该区块链开放的API进行限定查询。<br>3.私有区块链<br>私有区块链（Private Block Chains)：仅仅使用区块链的总账技术进行记账，可以是一个公司，也可以是个人，独享该区块链的写入权限，本链与其他的分布式存储方案没有太大区别。传统金融都是想实验尝试私有区块链，而公链的应用例如bitcoin已经工业化，私链的应用产品还在摸索当中。</p>
<p>特征：</p>
<p>去中心化<br>开放化<br>独立性<br>安全性<br>匿名性</p>
<p>架构模型：<br>  数据层<br>  网络层<br>  共同层<br>  激励层<br>  合约层<br>  应用层<br>核心技术：<br>分布式账本<br>非对称加密<br>共识机制<br>智能合约<br>应用：<br>金融<br>物联网<br>公共服务<br>数字版权<br>保险行业<br>公益领域<br>最后：<br>   区块链的内涵是丰富的，不仅仅只是打击虚拟货币，一些打着区块链旗号关于虚拟货币的推广宣传活动都是违法违规的。以上就是我的见解，  </p>
<p>   摘录自：<a href="https://baike.baidu.com/item/%E5%8C%BA%E5%9D%97%E9%93%BE/13465666?fr=aladdin">https://baike.baidu.com/item/%E5%8C%BA%E5%9D%97%E9%93%BE/13465666?fr=aladdin</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何给网站添加免费的 https 证书</title>
    <url>/2020/10/07/%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>最近部署了一个新服务，想给域名启用 https，结果搜了半天，在我的博客里只发现了这一篇笔记：阿里云免费证书域名启用 https</p>
<a id="more"></a>
<p>😹 只能说给网站启用 https 太简单了，之前都没留下笔记，为了之后方便，简单记录一下。</p>
<p>我使用的是 Let’s Encrypt 的免费证书。</p>
<p>按照下面的操作一步步来就行了。</p>
<p>1、去 certbot 官网。</p>
<p>2、在页面上选择一下你用的 Web 服务器和操作系统。比如，我选的 Nginx 和 Ubuntu 18.04</p>
<p>3、页面上会出现操作步骤，按照提示的步骤一步步执行命令就可以了。</p>
<p>需要注意执行到 sudo certbot –nginx 的时候，会出现两个协议：</p>
<p>第一个，是问你要不要同意他们的服务协议，选择“同意”。</p>
<p>第二个，是问你要不要共享你的邮箱给他们，他们偶尔会发一些他们基金会的新闻一类的。我选了“不同意”（因为我不知道以后有没有退订选项 😂）。</p>
<p>之后 certbot 会自动扫描你的 Nginx 的配置，寻找域名列表然后让你选择想配置 https 证书的域名（好像可以同时配置多个域名）。</p>
<p>如果没找到域名的话，会让你手动输入一个域名。</p>
<p>之后会问你，要不要强制把 http 的链接跳转到 https 上，当然选“是”了。</p>
<p>之后 certbot 会帮你把 Nginx 一切都配置好。你直接访问域名看一下效果即可。服务真是相当的贴心。。。。🎉</p>
<p>耗叔的这篇文章 如何免费的让网站启用HTTPS|酷 壳 - CoolShell 提到配置http2 传输性能更好。</p>
<p>要求 Nginx 版本要大于 1.9.5。HTTP2 具有更快的 HTTPS 传输性能，非常值得开启。需要开启 HTTP/2 其实很简单，只需要在 nginx.conf 的 listen 443 ssl; 后面加上 http2 就好了。如下所示：</p>
<p>listen 443 ssl http2; # managed by Certbot<br>ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot<br>ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot<br>include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot<br>然后，nginx -s reload 就好了。</p>
]]></content>
  </entry>
</search>
